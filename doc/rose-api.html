<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>Rose Reference Guide: API</title>
  <meta name="author" content="Rose Team, Met Office, UK" />
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <link rel="icon" href="rose-icon.png" type="image/png" />
  <link rel="shortcut icon" href="rose-icon.png" type="image/png" />
  <link rel="stylesheet" type="text/css" href="rose-doc.css" />
  <link rel="stylesheet" type="text/css" href=
  "google-code-prettify/prettify.css" />
  <script type="text/javascript" src="jquery.min.js">
</script>
  <script type="text/javascript" src="google-code-prettify/prettify.js">
</script>
  <script type="text/javascript" src="prettify-rose-conf.js">
</script>
  <script type="text/javascript" src="prettify-cylc-suite-rc.js">
</script>
  <script type="text/javascript" src="rose-doc.js">
</script>
  <script type="text/javascript" src="rose-version.js">
</script>
</head>

<body>
  <div class="header-footer" id="body-header">
    <address>
      &copy; British Crown Copyright 2012-3 <a href=
      "http://www.metoffice.gov.uk">Met Office</a>. See <a href=
      "rose-terms-of-use.html">Terms of Use</a>.<br />
      This document is released under the <a href=
      "http://www.nationalarchives.gov.uk/doc/open-government-licence/" rel=
      "license">Open Government Licence</a>.<br />
      <span id="rose-version"></span>
    </address><img id="rose-icon" src="rose-icon.png" alt="Rose" />

    <p><a href=".">Rose Documentation</a></p>
  </div>

  <div id="body-main">
    <h1>Rose Reference Guide: API</h1>

    <div id="content"></div>

    <h2 id="intro">Introduction</h2>

    <p>Rose is mainly implemented in <a href="www.python.org">Python</a> and
    <a href="http://www.gnu.org/software/bash/">bash</a>.</p>

    <p>The sub-sections below explain how to make use of various application
    programming interfaces within Rose which are designed for extension. These
    are useful for extending Rose components or creating standalone programs
    that seek to manipulate Rose information.</p>

    <p>Most of these interfaces require a good knowledge of Python.</p>

    <h2 id="gtk">Rose GTK library</h2>

    <p>The Rose/Rosie GUIs (such as the config editor) are written using the
    Python bindings for the GTK GUI toolkit (<a href=
    "www.pygtk.org">PyGTK</a>). You can write your own custom GTK widgets and
    use them within Rose. They should live with the metadata under the
    <code>lib/python/widget/</code> directory.</p>

    <h3 id="gtk:config-edit:values">Value Widgets</h3>

    <p>Value widgets are used for operating on the values of settings. In the
    config editor, they appear next to the menu button and name label. There
    are builtin value widgets in Rose such as text entry boxes, radio buttons,
    and drop-down menus. These are chosen by the config editor based on
    metadata - for example, if a setting has an integer type, the value widget
    will be a spin button.</p>

    <p>The config editor supports adding user-defined custom widgets which
    replace the default widgets. These have the same API, but live in the
    metadata directories rather than the Rose source code.</p>

    <p>For example, you may wish to add widgets that deal with dates (e.g.
    using something based on a <a href=
    "http://developer.gnome.org/pygtk/stable/class-gtkcalendar.html">calendar</a>
    widget) or use a <a href=
    "http://www.pygtk.org/pygtk2tutorial/sec-RangeWidgetEample.html">slider</a>
    widget for numbers. You may even want something that uses an image-based
    interface such as a latitude-longitude chooser based on a map.</p>

    <p>Normally, widgets will be placed within the metadata directory for the
    suite or application. Widgets going into the Rose core should be added to
    the <code>lib/python/rose/config_editor/valuewidget/</code> directory in a
    Rose distribution.</p>

    <h4 id="gtk:config-edit:values:example">Example</h4>

    <p>See the <a href="rose-rug-advanced-tutorials-widget.html">Advanced
    Tutorial</a>.</p>

    <h4 id="gtk:config-edit:values:api">API Reference</h4>

    <p>All value widgets, custom or core, use the same API. This means that a
    good practical reference is the set of existing value widgets in the
    package <code>rose.config_editor.valuewidget</code>.</p>

    <p>The procedure for implementing a custom value widget is as follows:</p>

    <p>Assign a <var>widget[rose-config-edit]</var> attribute to the relevant
    variable in the metadata configuration, e.g.</p>
    <pre class="prettyprint lang-rose_conf">
[namelist:VerifConNL/ScalarAreaCodes]
widget[rose-config-edit]=module_name.AreaCodeChooser
</pre>

    <p>where the widget class lives in the module <var>module_name</var> under
    <code>lib/python/widget/</code> in the metadata directory for the
    application or suite. Modules are imported by the config editor on
    demand.</p>

    <p>This class should have a constructor of the form</p>
    <pre class="prettyprint">
class AreaCodeChooser(gtk.HBox):

    def __init__(self, value, metadata, set_value, hook, arg_str=None)
</pre>

    <p>with the following arguments</p>

    <dl>
      <dt><code>value</code></dt>

      <dd>a string that represents the value that the widget should
      display.</dd>

      <dt><code>metadata</code></dt>

      <dd>
        <p>a map or dictionary of configuration metadata properties for this
        value, such as</p>
        <pre class="prettyprint">
{'type': 'integer', 'help': 'This is used to count something'}
</pre>

        <p>You may not need to use this information.</p>
      </dd>

      <dt><code>set_value</code></dt>

      <dd>
        <p>a function that should be called with a new string value of this
        widget, e.g.</p>
        <pre class="prettyprint">
set_value("20")
</pre>
      </dd>

      <dt><code>hook</code></dt>

      <dd>
        <p>An instance of a class
        <code>rose.config_editor.valuewidget.ValueWidgetHook</code> containing
        callback functions that you should connect some of your widgets to.</p>
      </dd>

      <dt><code>arg_str</code></dt>

      <dd>
        <p>is a keyword argument that stores extra text given to the
        <samp>widget</samp> option in the metadata, if any:</p>
        <pre class="prettyprint lang-rose_conf">
widget[rose-config-edit]=modulename.ClassName arg1 arg2 arg3 ...
</pre>

        <p>would give a <code>arg_str</code> of <code>"arg1 arg2 arg3
        ..."</code>. This could help configure your widget - for example, for a
        table based widget, you might give the column names</p>:
        <pre class="prettyprint lang-rose_conf">
widget[rose-config-edit]=table.TableValueWidget NAME ID WEIGHTING
</pre>This means that you can write a generic widget and then configure it for
different cases.
      </dd>
    </dl>

    <p><code>hook</code> contains some callback functions that you should
    implement:</p>

    <dl>
      <dt><code>hook.get_focus(widget) -&gt; None</code></dt>

      <dd>
        <p>which you should connect your top-level widget (<samp>self</samp>)
        to as follows:</p>
        <pre class="prettyprint">
    self.grab_focus = lambda: hook.get_focus(my_favourite_focus_widget)
</pre>

        <p>or define a method in your class</p>
        <pre class="prettyprint">
def grab_focus(self):
    """Override the focus method, so we can scroll to a particular widget."""
    return hook.get_focus(my_favourite_focus_widget)
</pre>

        <p>which allows the correct widget
        (<samp>my_favourite_focus_widget</samp>) in your container to receive
        the focus such as a gtk.Entry (<code>my_favourite_focus_widget</code>)
        and will also trigger a scroll action on a config editor page. This is
        important to implement to get the proper global find functionality.</p>
      </dd>

      <dt><code>hook.trigger_scroll(widget) -&gt; None</code></dt>

      <dd>
        <p>accessed by</p>
        <pre class="prettyprint">
    hook.trigger_scroll(my_favourite_focus_widget)
</pre>

        <p>This should be connected to the <code>focus-in-event</code> GTK
        signal of your top-level widget (<samp>self</samp>):</p>
        <pre class="prettyprint">
        self.entry.connect('focus-in-event',
                           hook.trigger_scroll)
        
</pre>

        <p>This also is used to trigger a config editor page scroll to your
        widget.</p>
      </dd>
    </dl>

    <p>You may implement the following optional methods for your widget, which
    help to preserve cursor position when a widget is refreshed:</p>

    <dl>
      <dt><code>set_focus_index(focus_index) -&gt; None</code></dt>

      <dd>
        <p>A method that takes a number as an argument, which is the current
        cursor position relative to the characters in the variable value:</p>
        <pre class="prettyprint">
def set_focus_index(self, focus_index):
    """Set the cursor position to focus_index."""
    self.entry.set_position(focus_index)
</pre>

        <p>For example, a <code>focus_index</code> of <samp>0</samp> means that
        your widget should set the cursor position to the beginning of the
        value. A <code>focus_index</code> of <samp>4</samp> for a variable
        value of <samp>Operational</samp> means that the cursor should be
        placed between the <samp>r</samp> and the <samp>a</samp>.</p>

        <p>This has no real meaning or importance for widgets that don't
        display editable text. If you do not supply this method, the config
        editor will attempt to do the right thing anyway.</p>
      </dd>

      <dt><code>get_focus_index() -&gt; focus_index</code></dt>

      <dd>
        <p>A method that takes no arguments and returns a number which is the
        current cursor position relative to the characters in the variable
        value:</p>
        <pre class="prettyprint">
def get_focus_index(self):
    """Return the cursor position."""
    return self.entry.get_position()
</pre>

        <p>This has no real meaning or importance for widgets that don't
        display editable text. If you do not supply this method, the config
        editor will guess the cursor position anyway, based on the last change
        to the variable value.</p>
      </dd>

      <dt><code>handle_type_error(is_in_error) -&gt; None</code></dt>

      <dd>
        <p>The default behaviour when a variable error is added or removed is
        to re-instantiate the widget (refresh and redraw it). This can be
        overridden by defining this method in your value widget class. It takes
        a boolean <code>is_in_error</code> which is <samp>True</samp> if there
        is a value (type) error and <samp>False</samp> otherwise:</p>
        <pre class="prettyprint">
def handle_type_error(self, is_in_error):
    """Change behaviour based on whether the variable is_in_error."""
    icon_id = gtk.STOCK_DIALOG_ERROR if is_in_error else None
    self.entry.set_icon_from_stock(0, gtk.STOCK_DIALOG_ERROR)       
</pre>

        <p>For example, this is used in a built-in widget for the quoted string
        types <code>string</code> and <code>character</code>. The quotes around
        the text are normally hidden, but the <code>handle_type_error</code>
        shows them if there is an error. The method also keeps the keyboard
        focus, which is the main purpose.</p>

        <p>You may not have much need for this method, as the default error
        flagging and cursor focus handling is normally sufficient.</p>
      </dd>
    </dl>

    <p>All the existing variable value widgets are implemented using this API,
    so a good resource is the modules within the
    lib/python/rose/config_editor/valuewidget package.</p>

    <h3 id="gtk:config-edit:pages">Config Editor Custom Pages</h3>

    <p>A 'page' in the config editor is the container inside a tab or detached
    tab that (by default) contains a table of variable widgets. The config
    editor allows custom 'pages' to be defined that may or may not use the
    standard set of variable widgets (menu button, name, value widget). This
    allows any presentation of the underlying variable information.</p>

    <p>For example, you may wish to present the variables in a more structured,
    two-dimensional form rather than as a simple list. You may want to strip
    down or add to the information presented by default - e.g. hiding names or
    embedding widgets within a block of help text.</p>

    <p>You may even wish to do something off-the-wall such as an <a href=
    "http://code.google.com/p/jrfonseca/wiki/XDot">xdot-based</a> widget
    set!</p>

    <h4 id="gtk:config-edit:pages:api">API Reference</h4>

    <p>The procedure for generating a custom page widget is as follows:</p>

    <p>Assign a <code>widget</code> option to the relevant namespace in the
    metadata configuration, e.g.</p>
    <pre class="prettyprint lang-rose_conf">
    [ns:namelist/STASHNUM]
    widget[rose-config-edit]=module_name.MyGreatBigTable
</pre>

    <p>The widget class should have a constructor of the form</p>
    <pre class="prettyprint">
    class MyGreatBigTable(gtk.Table):

        def __init__(self, real_variable_list, missing_variable_list,
                     variable_functions_class_inst, show_modes_dict,
                     arg_str=None):
</pre>

    <p>The class can inherit from any <code>gtk.Container</code>-derived
    class.</p>

    <p>The constructor arguments are</p>

    <dl>
      <dt><code>real_variable_list</code></dt>

      <dd>a list of the Variable objects (x.name, x.value, x.metadata, etc from
      the rose.variable module). These are the objects you will need to
      generate your widgets around.</dd>

      <dt><code>missing_variable_list</code></dt>

      <dd>a list of 'missing' Variable objects that could be added to the
      container. You will only need to worry about these if you plan to show
      them by implementing the <code>'View Latent'</code> menu functionality
      that we'll discuss further on.</dd>

      <dt><code>variable_functions_class_inst</code></dt>

      <dd>an instance of the class
      rose.config_editor.ops.variable.VariableOperations.This contains methods
      to operate on the variables. These will update the undo stack and take
      care of any errors. These methods are the only ways that you should write
      to the variable states or values. For documentation, see the module
      lib/python/rose/config_editor/ops/variable.py.</dd>

      <dt><code>show_modes_dict</code></dt>

      <dd>
        a dictionary that looks like this:
        <pre class="prettyprint">
    show_modes_dict = {'latent': False, 'fixed': False, 'ignored': True,
                       'user-ignored': False, 'title': False,
                       'flag:optional': False, 'flag:no-meta': False}
</pre>

        <p>which could be ignored for most custom pages, as you need. The
        meaning of the different keys in a non-custom page is:</p>

        <dl>
          <dt><code>'latent'</code></dt>

          <dd>False means don't display widgets for variables in the metadata
          or that have been deleted (the <code>variable_list.ghosts</code>
          variables)</dd>

          <dt><code>'fixed'</code></dt>

          <dd>False means don't display widgets for variables if they only have
          one value set in the metadata <code>values</code> option.</dd>

          <dt><code>'ignored'</code></dt>

          <dd>False means don't display widgets for variables if they're
          ignored (in the configuration, but commented out).</dd>

          <dt><code>'user-ignored'</code></dt>

          <dd>(If <code>ignored</code> is False) False means don't display
          widgets for user-ignored variables. True means always show
          user-ignored variables.</dd>

          <dt><code>'title'</code></dt>

          <dd>Short for 'View with no title', False means show the title of a
          variable, True means show the variable name instead.</dd>

          <dt><code>'flag:optional'</code></dt>

          <dd>True means indicate if a variable is <code>optional</code>, and
          False means do not show an indicator.</dd>

          <dt><code>'flag:no-meta'</code></dt>

          <dd>True means indicate if a variable has any metadata content, and
          False means do not show an indicator.</dd>
        </dl>

        <p>If you wish to implement actions based on changes in these
        properties (e.g. displaying and hiding fixed variables depending on the
        'fixed' setting), the custom page widget should expose a method named
        'show_mode_change' followed by the key. However, 'ignored' is handled
        separately (more below). These methods should take a single boolean
        that indicates the display status. For example:</p>
        <pre class="prettyprint">
def show_fixed(self, should_show)
</pre>

        <p>The argument <code>should_show</code> is a boolean. If True, fixed
        variables should be shown. If False, they should be hidden by your
        custom container.</p>
      </dd>

      <dt><code>arg_str</code></dt>

      <dd>
        <p>is a keyword argument that stores extra text given to the
        <samp>widget</samp> option in the metadata, if any:</p>
        <pre class="prettyprint lang-rose_conf">
widget[rose-config-edit] = modulename.ClassName arg1 arg2 arg3 ...
</pre>

        <p>would give a <code>arg_str</code> of <code>"arg1 arg2 arg3
        ..."</code>. This could help configure your widget - for example, for a
        table based widget, you might give the column names</p>:
        <pre class="prettyprint lang-rose_conf">
widget[rose-config-edit] = table.TableValueWidget NAME ID WEIGHTING
</pre>This means that you can write a generic widget and then configure it for
different cases.
      </dd>
    </dl>

    <p>Refreshing the whole page in order to display a small change to a
    variable (the default) can be undesirable. To deal with this, custom page
    widgets can optionally expose some variable-change specific methods that do
    this themselves. These take a single rose.variable.Variable instance as an
    argument.</p>

    <dl>
      <dt><code>def add_variable_widget(self, variable) -&gt; None</code></dt>

      <dd>will be called when a variable is created.</dd>

      <dt><code>def reload_variable_widget(self, variable) -&gt;
      None</code></dt>

      <dd>will be called when a variable's status is changed, e.g. it goes into
      an error state.</dd>

      <dt><code>def remove_variable_widget(self, variable) -&gt;
      None</code></dt>

      <dd>will be called when a variable is removed.</dd>

      <dt><code>def update_ignored(self) -&gt; None</code></dt>

      <dd>will be called to allow you to update ignored widget display, if (for
      example) you show/hide ignored variables. If you don't have any custom
      behaviour for ignored variables, it's worth writing a method that does
      nothing - e.g. one that contains just <code>pass</code>).</dd>
    </dl>

    <p>If you take the step of using your own variable widgets, rather than the
    VariableWidget class in lib/python/rose/config_editor/variable.py (the
    default for normal config-edit pages), each variable-specific widget should
    have an attribute <code>variable</code> set to their rose.variable.Variable
    instance. You can implement 'ignored' status display by giving the widget a
    method <code>set_ignored</code> which takes no arguments. This should
    examine the <code>ignored_reason</code> dictionary attribute of the
    widget's <code>variable</code> instance - the variable is ignored if this
    is not empty. If the variable is ignored, the widget should indicate this
    e.g. by greying out part of it.</p>

    <p>All existing page widgets use this API, so a good resource is the
    modules in lib/python/rose/config_editor/pagewidget/.</p>

    <p>Generally speaking, a visible change, click, or key press in the custom
    page widget should make instant changes to variable value(s), and the value
    that the user sees. Pages are treated as temporary, superficial views of
    variable data, and changes are always assumed to be made directly to the
    main copy of the configuration in memory (this is automatic when the
    rose.config_editor.ops.variable.VariableOperations methods are used, as
    they should be). Closing the page shouldn't change, or lose, any data! The
    custom class should return a gtk object to be packed into the page
    framework, so it's best to subclass from an existing gtk Container type
    such as gtk.VBox (or gtk.Table, in the example above).</p>

    <p>In line with the general philosophy, metadata should not be critical to
    page operations - it should be capable of displaying variables even when
    they have no or very little metadata, and still make sense if some
    variables are missing or new.</p>

    <h2 id="macro">Rose Macros</h2>

    <p>Rose macros manipulate or check configurations, often based on their
    metadata. There are three types of macros:</p>

    <ul>
      <li>Checkers (validators) - check a configuration, perhaps using
      metadata.</li>

      <li>Changers (transformers) - change a configuration e.g. adding/removing
      options.</li>

      <li>Upgraders - these are special transformer macros for upgrading and
      downgrading configurations.</li>
    </ul>

    <p>There are built-in rose macros that handle standard behaviour such as
    trigger changing and type checking.</p>

    <p>This section explains how to add your own custom macros to transform and
    validate configurations. See <a href="#upgrade">Upgrade Macro API</a> for
    upgrade macros.</p>

    <p>Macros use a Python API, and should be written in Python, unless you are
    doing something very fancy. In the absence of a Python house style, it's
    usual to follow the standard Python style guidance (<a href=
    "http://www.python.org/dev/peps/pep-0008/">PEP8</a>, <a href=
    "http://www.python.org/dev/peps/pep-0257/">PEP257</a>).</p>

    <p>They can be run within <code>rose config-edit</code> or via <code>rose
    macro.</code></p>

    <p>You should avoid writing checker macros if the checking can be expressed
    via metadata.</p>

    <h3 id="macro:location">Location</h3>

    <p>A module containing macros should be stored under a directory
    <code>lib/python/macros/</code> in the metadata for a configuration. This
    directory should be a Python package.</p>

    <p>When developing macros for Rose internals, macros should be placed in
    the <code>rose.macros</code> package in the Rose Python library. They
    should be referenced by the <code>lib/python/rose/macros/__init__.py</code>
    classes and a call to them can be added in the
    <code>lib/python/rose/config_editor/main.py</code> module if they need to
    be run implicitly by the config editor.</p>

    <h3 id="macro:code">Code</h3>

    <h4 id="macro:code:examples">Examples</h4>

    <p>See the macro <a href="rose-rug-advanced-tutorials-macro.html">Advanced
    Tutorial</a>.</p>

    <h4 id="macro:code:api">API Reference</h4>

    <p>Macros should subclass from <code>rose.macro.MacroBase</code>. There are
    two types of macro - checkers (validators) which do not alter a
    configuration but provide error messages, and changers (transformers) which
    return an altered configuration. A macro class can contain one or both of
    these behaviours.</p>

    <p>Your macro should provide a method called <code>validate</code> (for
    <em>checking</em>) and/or a method called <code>transform</code> (for
    <em>changing</em>). These methods should accept two
    <code>rose.config.ConfigNode</code> instances as arguments - one is the
    configuration, and one is the metadata configuration that provides
    information about the configuration items.</p>

    <p>A validator macro should look like:</p>
    <pre class="prettyprint">
import rose.macro

class SomeValidator(rose.macro.MacroBase):

    """This does some kind of check."""

    def validate(self, config, meta_config=None):
        # Some check on config appends to self.reports using self.add_report
        return self.reports
</pre>

    <p>The returned list should be a list of rose.macro.MacroReport objects
    containing the section, option, value, and warning strings for each setting
    that is in error. These are initialised behind the scenes by calling the
    inherited method <code>rose.macro.MacroBase.add_report</code> via
    <code>self.add_report</code>. This has the form:</p>
    <pre class="prettyprint">
    def add_report(self, report_list, section=None, option=None, value=None,
                   info=None, is_warning=False):
</pre>

    <p>This means that you should call it with the relevant section first, then
    the relevant option, then the relevant value, then the relevant error
    message, and optionally a warning flag that we'll discuss later. If the
    setting is a section, the option should be <code>None</code> and the value
    None. For example,</p>
    <pre class="prettyprint">
    def validate(self, config, meta_config=None):
        editor_value = config.get(["env", "MY_FAVOURITE_STREAM_EDITOR"]).value
        if editor_value != "sed":
            self.add_report("env",                         # Section
                            "MY_FAVOURITE_STREAM_EDITOR",  # Option
                            editor_value,                  # Value
                            "Should be 'sed'!")            # Message
        return self.reports
</pre>

    <p>Validator macros have the option to give warnings, which do not count as
    formal errors in the Rose config editor GUI. These should be used when
    something <em>may</em> be wrong, such as warning when using an
    advanced-developer-only option. They are invoked by passing a 5th argument
    to <code>self.add_report</code>, <code>is_warning</code>, like so:</p>
    <pre class="prettyprint">
            self.add_report("env",
                            "MY_FAVOURITE_STREAM_EDITOR",
                            editor_value,
                            "Could be 'sed'",
                            is_warning=True)
</pre>

    <p>A transformer macro should look like:</p>
    <pre class="prettyprint">
import rose.macro

class SomeTransformer(rose.macro.MacroBase):

    """This does some kind of change to the config."""

    def transform(self, config, meta_config=None):
        # Some operation on config which calls self.add_report for each change.
        return config, self.reports
</pre>

    <p>The returned list should be a list of 4-tuples containing the section,
    option, value, and information strings for each setting that was changed
    (e.g. added, removed, value changed). If the setting is a section, the
    option should be <code>None</code> and the value None. If an option was
    removed, the value should be the old value - otherwise it should be the new
    one (added/changed). For example,</p>
    <pre class="prettyprint">
    def transform(self, config, meta_config=None):
        """Add some more snow control."""
        if config.get(["namelist:snowflakes"]) is None:
            config.set(["namelist:snowflakes"])
            self.add_report(list_of_changes,
                            "namelist:snowflakes", None, None,
                            "Updated snow handling in time for Christmas")
            config.set(["namelist:snowflakes", "l_unique"], ".true.")
            self.add_report("namelist:snowflakes", "l_unique", ".true.",
                            "So far, anyway.")
        return config, self.reports
</pre>

    <h2 id="upgrade">Rose Upgrade Macros</h2>

    <p>Rose upgrade macros are used to upgrade application configurations
    between metadata versions. They are classes, very similar to the Transform
    macros above, but with a few differences:</p>

    <ul>
      <li>an <var>upgrade</var> method instead of a <var>transform</var>
      method</li>

      <li>an optional <var>downgrade</var> method, identical in API to the
      <var>upgrade</var> method, but intended for performing the reverse
      operation</li>

      <li>a more helpful API via <code>rose.upgrade.MacroUpgrade</code>
      methods</li>

      <li><samp>BEFORE_TAG</samp> and <samp>AFTER_TAG</samp> attributes - the
      version of metadata they apply to (<samp>BEFORE_TAG</samp>) and the
      version they upgrade to (<samp>AFTER_TAG</samp>)</li>
    </ul>

    <p>An example upgrade macro might look like this:</p>
    <pre class="prettyprint">
class Upgrade272to273(rose.upgrade.MacroUpgrade):

    """Upgrade from 27.2 to 27.3."""

    BEFORE_TAG = "27.2"
    AFTER_TAG = "27.3"

    def upgrade(self, config, meta_config=None):
        self.add_setting(config, ["env", "NEW_VARIABLE"], "0")
        self.remove_setting(config, ["namelist:old_things", "OLD_VARIABLE"])
        return config, self.reports
</pre>

    <p>The class name is unimportant - the <samp>BEFORE_TAG</samp> and
    <samp>AFTER_TAG</samp> identify the macro.</p>

    <p>Metadata versions are usually structured in a
    <samp>rose-meta/CATEGORY/VERSION/</samp> hierarchy - where
    <samp>CATEGORY</samp> denotes the type or family of application (sometimes
    it is the command used), and <samp>VERSION</samp> is the particular version
    e.g. <samp>27.2</samp> or <samp>HEAD</samp>.</p>

    <p>Upgrade macros live under the <samp>CATEGORY</samp> directory in a
    <samp>versions.py</samp> file -
    <samp>rose-meta/CATEGORY/versions.py</samp>.</p>

    <p>Upgrade macros are subclasses of <code>rose.upgrade.MacroUpgrade</code>.
    They have all the functionality of the transform macros documented above.
    <code>rose.upgrade.MacroUpgrade</code> also has some additional convenience
    methods defined for you to call. All methods return <code>None</code>
    unless otherwise specified.</p>

    <dl>
      <dt><code>def act_from_files(self, config, downgrade=False)</code></dt>

      <dd>
        <p>A method that takes the app configuration (<samp>config</samp>, a
        <code>rose.config.ConfigNode</code> instance) and an optional boolean
        <samp>downgrade</samp> keyword argument. This initiates a search for
        <samp>etc/VERSION/rose-macro-add.conf</samp> and
        <samp>etc/VERSION/rose-macro-remove.conf</samp>, where VERSION is equal
        to the <samp>BEFORE_TAG</samp> of the macro. These files should be Rose
        app config-like patch files, containing settings to be added
        (<samp>rose-macro-add.conf</samp>) and settings to be removed
        (<samp>rose-macro-remove.conf</samp>). If downgrading
        (<samp>downgrade</samp> set to <samp>True</samp>), the settings in
        <samp>rose-macro-remove.conf</samp> will be added, and the ones in
        <samp>rose-macro-add.conf</samp> removed.</p>
        <pre class="prettyprint">
    def upgrade(self, config, meta_config=None):
        self.act_from_files(config)
        return config, self.reports
</pre>

        <p>Note that you can use other methods (below) as well as this in the
        same <samp>upgrade</samp>.</p>

        <p>If settings are defined in either file, and changes can be made, the
        <code>self.reports</code> will be updated automatically.</p>
      </dd>

      <dt><code>def add_setting(self, config, keys, value=None, forced=False,
      state=None, comments=None, info=None):</code></dt>

      <dd>
        <p>A method that attempts to add the setting defined by the list
        <samp>keys</samp> (<samp>[section]</samp> or <samp>[section,
        option]</samp> strings) with the value <samp>value</samp> to the app
        config <samp>config</samp>. The arguments mostly follow
        <code>rose.config.ConfigNode</code> attributes, and are as follows:</p>

        <dl>
          <dt><samp>config</samp></dt>

          <dd>The application configuration object
          (<code>rose.config.ConfigNode</code> instance)</dd>

          <dt><samp>keys</samp></dt>

          <dd>A list of strings denoting config settings -
          <code>[section_name]</code> for a section, <code>[section_name,
          option_name]</code> for an option. For example, it might be
          <code>["namelist:foo", "bar"]</code>.</dd>

          <dt><samp>value</samp> (optional)</dt>

          <dd>A string or <code>None</code> denoting the new setting value.
          <code>None</code> should be used for sections only. Options must have
          a string <code>value</code> defined.</dd>

          <dt><samp>forced</samp> (optional)</dt>

          <dd>If the setting already exists, override the value to the new
          <code>value</code>.</dd>

          <dt><samp>state</samp> (optional)</dt>

          <dd>Set the state of the new setting
          (<code>rose.config.ConfigNode</code> states) - <code>None</code>
          implies the default, which is
          <code>rose.config.ConfigNode.STATE_NORMAL</code>. You may also use
          <code>rose.config.ConfigNode.STATE_USER_IGNORED.</code></dd>

          <dt><samp>comments</samp> (optional)</dt>

          <dd>A list of comment strings (lines) for the new setting or
          <code>None</code>.</dd>

          <dt><samp>info</samp> (optional)</dt>

          <dd>A short string containing no new lines, describing the addition
          of the setting.</dd>
        </dl>
      </dd>

      <dd>
        <p>Example usage:</p>
        <pre class="prettyprint">
    def upgrade(self, config, meta_config=None):
        self.add_setting(config, ["namelist:breakfast_nl", "bacon"], "2",
                         comments=["Mmmm. Bacon."], info="Add for food:#810")
        return config, self.reports
</pre>
      </dd>

      <dt><code>def change_setting_value(self, config, keys, value,
      forced=False, comments=None, info=None):</code></dt>

      <dd>
        <p>A method that attempts to change an existing setting value defined
        by <samp>keys</samp> to a new one (<samp>value</samp>) in the app
        config <samp>config</samp>. The arguments are:</p>

        <dl>
          <dt><samp>config</samp>, <samp>keys</samp>, <samp>comments</samp>,
          <samp>info</samp></dt>

          <dd>As in <code>add_setting</code> above.</dd>

          <dt><samp>value</samp></dt>

          <dd>Required argument, must be a string for option values, and can be
          <code>None</code> for section values.</dd>

          <dt><samp>forced</samp> (optional)</dt>

          <dd>Add the setting if it does not exist.</dd>
        </dl>

        <p>Example usage:</p>
        <pre class="prettyprint">
    def upgrade(self, config, meta_config=None):
        self.change_setting_value(config, ["namelist:breakfast_nl", "coffee"], "'more'",
                                  info="Add for food:#820")
        return config, self.reports
</pre>
      </dd>

      <dt><code>def get_setting_value(self, config, keys, no_ignore=False):
      (-&gt; value)</code></dt>

      <dd>
        <p>A method that returns a setting value or <code>None</code>,
        functionally similar to <code>rose.config.ConfigNode.get</code>. The
        arguments are:</p>

        <dl>
          <dt><samp>config</samp>, <samp>keys</samp></dt>

          <dd>
            <p>As in <code>add_setting</code> above.</p>
          </dd>

          <dt><samp>no_ignore</samp> (optional)</dt>

          <dd><code>False</code> means return the setting value if the setting
          is ignored. <code>True</code> means return <code>None</code> if the
          setting is ignored. If the setting is missing, <code>None</code> is
          returned.</dd>
        </dl>

        <p>Example usage:</p>
        <pre class="prettyprint">
    def upgrade(self, config, meta_config=None):
        if self.get_setting_value(
                    config, ["namelist:breakfast_nl", "coffee"]) == "'empty'":
            self.add_setting(config, ["namelist:breakfast_nl", "tea"],
                             "'extra_strong'")
        return config, self.reports    
</pre>
      </dd>

      <dt><code>def remove_setting(self, config, keys, info=None):</code></dt>

      <dd>
        <p>A method that removes a setting defined by <samp>keys</samp> in
        <samp>config</samp> with an optional <samp>info</samp> message. The
        arguments are:</p>

        <dl>
          <dt><samp>config</samp>, <samp>keys</samp>, <samp>info</samp></dt>

          <dd>As in <code>add_setting</code> above.</dd>
        </dl>

        <p>Example usage:</p>
        <pre class="prettyprint">
    def upgrade(self, config, meta_config=None):
        self.remove_setting(config, ["namelist:breakfast_nl", "cheeseburger"],
                            info="Cheeseburgers are for lunch")
        return config, self.reports
</pre>
      </dd>

      <dt><code>def enable_setting(self, config, keys, info=None):</code></dt>

      <dd>
        <p>A method to make sure a setting defined by <samp>keys</samp> in
        <samp>config</samp> is not user-ignored. The arguments are:</p>

        <dl>
          <dt><samp>config</samp>, <samp>keys</samp>, <samp>info</samp></dt>

          <dd>As in <code>add_setting</code> above.</dd>
        </dl>

        <p>Example usage:</p>
        <pre class="prettyprint">
    def upgrade(self, config, meta_config=None):
        self.enable_setting(config, ["namelist:breakfast_nl", "egg_monitoring"])
        return config, self.reports
</pre>
      </dd>

      <dt><code>def ignore_setting(self, config, keys, info=None,
      state=rose.config.ConfigNode.STATE_USER_IGNORED):</code></dt>

      <dd>
        <p>Inverse of <code>enable_setting</code>, a method to make sure a
        setting defined by <samp>keys</samp> in <samp>config</samp> is ignored
        (default state is user-ignored). The arguments are:</p>

        <dl>
          <dt><samp>config</samp>, <samp>keys</samp>, <samp>info</samp></dt>

          <dd>As in <code>add_setting</code> above.</dd>

          <dt><samp>state</samp></dt>

          <dd>One of <code>rose.config.ConfigNode.STATE_USER_IGNORED</code>
          (default), <code>rose.config.ConfigNode.STATE_SYST_IGNORED</code>
          (trigger-ignored). When using it, you can just use
          <code>config.STATE...</code> rather than the full
          <code>rose.config.ConfigNode.STATE...</code>.</dd>
        </dl>

        <p>Example usage:</p>
        <pre class="prettyprint">
    def upgrade(self, config, meta_config=None):
        self.ignore_setting(config, ["namelist:breakfast_nl", "milk_bottle_date"])
        return config, self.reports
</pre>
      </dd>
    </dl>

    <p>There is an upgrade macro <a href=
    "rose-rug-advanced-tutorials-upgrade-dev.html">development tutorial</a> and
    more examples in the upgrade file for the upgrade <a href=
    "rose-rug-advanced-tutorials-upgrade-usage.html">usage tutorial</a>
    (<samp>versions.py</samp>), at
    <samp>$ROSE_HOME/etc/rose-meta/rose-demo-upgrade/versions.py</samp>, where
    <samp>$ROSE_HOME</samp> is the path to your local Rose distribution,
    locatable by invoking <code>rose --version</code>.</p>

    <h2 id="rosie-ws">Rosie Web</h2>

    <p>This section explains how to use the Rosie web service API. All Rosie
    discovery services (e.g. <code>rosie search</code>, <code>rosie go</code>,
    web page) use a <a href=
    "http://en.wikipedia.org/wiki/Representational_state_transfer">RESTful</a>
    API to interrogate a web server, which then interrogates an <a href=
    "http://planetofcoders.com/rdbms/">RDBMS</a>. Returned data is encoded in
    the <a href="http://www.json.org/">JSON</a> format.</p>

    <p>You may wish to utilise the Python class
    <code>rosie.ws_client.Client</code> as an alternative to this API.</p>

    <h3 id="rosie-ws:location">Location</h3>

    <p>The URLs to access the web API of a Rosie web service (with a given
    prefix name) can be found in your rose site configuration file as the value
    of <var>[rosie-id]prefix-ws.PREFIX_NAME</var>. To access the API for a
    given repository with prefix PREFIX_NAME, you must select a format (the
    only currently supported format is 'json') and use a url that looks
    like:</p>
    <pre>
http://host/PREFIX_NAME/get_known_keys?format=json
</pre>

    <h3 id="rosie-ws:usage">Usage</h3>The API contains the following methods:

    <dl>
      <dt><code>get_known_keys</code></dt>

      <dd>
        returns the main property names stored for suites (e.g. idx, branch,
        owner) plus any additional names specified in the site config and takes
        the format argument. For example, entering a URL in a web browser:
        <pre>
http://host/PREFIX_NAME/get_known_keys?format=json
</pre>

        <p>may give</p>
        <pre class="prettyprint">
["access-list", "idx", "issue-list", "branch", "owner", "project", "revision", "status",  "title"]  
</pre>
      </dd>

      <dt><code>get_optional_keys</code></dt>

      <dd>
        returns all unique optional or user-defined property names given in
        suite discovery information and takes the format argument. For example,
        entering this URL in Firefox:
        <pre>
http://host/PREFIX_NAME/get_optional_keys?format=json
</pre>

        <p>may give</p>
        <pre class="prettyprint">
["access-list", "description", "endgame_status", "operational_flag", "tag-list"]
</pre>
      </dd>

      <dt><code>get_query_operators</code></dt>

      <dd>
        returns all the SQL-like operators used to compare column values that
        you may use in queries (below) (e.g. <samp>eq</samp>, <samp>ne</samp>,
        <samp>contains</samp>, <samp>like</samp>) and takes the format
        argument. For example, entering this URL in a web browser:
        <pre>
http://host/PREFIX_NAME/get_query_operators?format=json
</pre>

        <p>may give</p>
        <pre class="prettyprint">
["eq", "ge", "gt", "le", "lt", "ne", "contains", "endswith", "ilike", "like", "match", "startswith"]
</pre>
      </dd>

      <dt><code>query</code></dt>

      <dd>
        takes a list of queries <code>q</code> and the format argument. The
        syntax of the query looks like:
        <pre>
CONJUNCTION+[OPEN_GROUP+]FIELD+OPERATOR+VALUE[+CLOSE_GROUP]
</pre>

        <p>where</p>

        <dl>
          <dt><code>CONJUNCTION</code></dt>

          <dd><kbd>and</kbd> or <kbd>or</kbd></dd>

          <dt><code>OPEN_GROUP</code></dt>

          <dd>optional, one or more <kbd>(</kbd></dd>

          <dt><code>FIELD</code></dt>

          <dd>e.g. <var>idx</var> or <var>description</var></dd>

          <dt><code>OPERATOR</code></dt>

          <dd>e.g. <kbd>contains</kbd> or <kbd>between</kbd>, one of the
          operators returned by <code>get_query_operators</code></dd>

          <dt><code>VALUE</code></dt>

          <dd>e.g. <samp>euro4m</samp> or <samp>200</samp></dd>

          <dt><code>CLOSE_GROUP</code></dt>

          <dd>optional, one or more <kbd>)</kbd></dd>
        </dl>

        <p>The first <code>CONJUNCTION</code> is technically superfluous. The
        <code>OPEN_GROUP</code> and <code>CLOSE_GROUP</code> do not have to be
        used. Entering this URL in a web browser:</p>
        <pre>
http://host/PREFIX_NAME/query?q=and+idx+endswith+78&amp;q=or+owner+eq+bob&amp;format=json
</pre>

        <p>may give</p>
        <pre class="prettyprint">
[{"idx": "mo1-aa078", "branch": "trunk", "revision": 200, "owner": "fred",
  "project": "fred's project.", "title": "fred's awesome suite",
  "status": "M ", "access-list": ["fred", "jack"], "description": "awesome"},
 {"idx": "mo1-aa090", "branch": "trunk", "revision": 350, "owner": "bob",
  "project": "var", "title": "A copy of var.vexcs.", "status": "M ",
  "access-list": ["*"], "operational": "Y"}]
</pre>

        <p>This returned all current suites that have an idx that ends with
        <samp>78</samp> and also all suites that have the owner
        <samp>bob</samp>. Each suite is returned as an entry in a list - each
        entry is an associative array of property name-value pairs. These pairs
        contain all database information about a suite.</p>

        <p><code>query</code> also takes the optional argument
        <code>all_revs</code> which switches on searching older revisions of
        current suites and deleted suites. For example, entering this URL in a
        web browser:</p>
        <pre>
http://host/mo1/json/query?q=and+idx+endswith+78&amp;all_revs&amp;format=json
</pre>

        <p>may give</p>
        <pre class="prettyprint">
[{"idx": "mo1-aa078", "branch": "trunk", "revision": 120, "owner": "fred",
  "project": "fred's project.", "title": "fred's new suite",
  "status": "A "}
 {"idx": "mo1-aa078", "branch": "trunk", "revision": 199, "owner": "fred",
  "project": "fred's project.", "title": "fred's awesome suite",
  "status": "M ", "access-list": ["fred", "jack"], "description": "awesome"},
 {"idx": "mo1-aa078", "branch": "trunk", "revision": 200, "owner": "fred",
  "project": "fred's project.", "title": "fred's awesome suite",
  "status": "M ", "access-list": ["fred", "jack"], "description": "awesome"}]
</pre>
      </dd>

      <dd>
        <p>This returned all past and present suites that have an idx that ends
        with <samp>78</samp>. You can see that older revisions of the
        <samp>aa078</samp> suite appear.</p>
      </dd>

      <dd>
        <p>You can also use parentheses in your search to group expressions.
        For example, entering this URL in a web browser:</p>
        <pre>
http://host/PREFIX_NAME/query?q=and+(+owner+eq+bob&amp;q=or+owner+eq+fred+)&amp;q=and+project+eq+test&amp;format=json
</pre>

        <p>would search for all suites that are owned by <samp>bob</samp> or
        <samp>fred</samp> that have the project <samp>test</samp>.</p>
      </dd>

      <dt><code>search</code></dt>

      <dd>
        takes any number of string arguments and the format argument and
        returns a list of matching suites with properties in the same format as
        <code>query</code>. The suite database is searched for suites with any
        property with a value that contains any of the string arguments. For
        example, entering this URL in a web browser:
        <pre>
http://host/PREFIX_NAME/search?var+bob+nowcast&amp;format=json
</pre>

        <p>may give</p>
        <pre class="prettyprint">
[{"idx": "mo1-aa090", "branch": "trunk", "revision": 330, "owner": "bob",
  "project": "um", "title": "A copy of um.alpra.", "status": "M ",
  "description": "Bob's UM suite"},
 {"idx": "mo1-aa092", "branch": "trunk", "revision": 340, "owner": "jim",
  "project": "var", "title": "6D Quantum VAR.", "status": "M ", 
  "location": "NAE"},
 {"idx": "mo1-aa100", "branch": "trunk", "revision": 352, "owner": "ops_account",
  "project": "nowcast", "title": "The operational Nowcast suite",
  "status": "M ", "ensemble": "yes"}]
</pre>

        <p>This returned all suites that contain one or more of these search
        terms. Each suite is returned as an entry in a list, and each entry is
        an associative array of suite property name-value pairs. These pairs
        contain all database information about a suite.</p>

        <p><code>search</code> also takes the optional argument
        <code>all_revs</code> in the same way as <code>query</code>, above.
        This switches on searching older revisions of current suites and
        deleted suites. For example, entering this URL in a web browser:</p>
        <pre>
http://host/PREFIX_NAME/search?var+bob&amp;all_revs&amp;format=json
</pre>

        <p>may give</p>
        <pre class="prettyprint">
[{"idx": "mo1-aa001", "branch": "trunk", "revision": 120, "owner": "bob",
  "project": "useless", "title": "Bob's useless suite.", "status": "A "},
 {"idx": "mo1-aa001", "branch": "trunk", "revision": 122, "owner": "bob",
  "project": "useless", "title": "Bob's useless suite.", "status": "D "},
 {"idx": "mo1-aa090", "branch": "trunk", "revision": 320, "owner": "bob",
  "project": "um", "title": "A copy of um.alpra.", "status": "A "},
 {"idx": "mo1-aa090", "branch": "trunk", "revision": 321, "owner": "bob",
  "project": "um", "title": "A copy of um.alpra.", "status": "M "},
 {"idx": "mo1-aa090", "branch": "trunk", "revision": 330, "owner": "bob",
  "project": "um", "title": "A copy of um.alpra.", "status": "M "},
 {"idx": "mo1-aa092", "branch": "trunk", "revision": 335, "owner": "jim",
  "project": "var", "title": "6D Quantum VAR.", "status": "A "},
 {"idx": "mo1-aa092", "branch": "trunk", "revision": 338, "owner": "jim",
  "project": "var", "title": "6D Quantum VAR.", "status": "M ",
  "location": "Africa"},
 {"idx": "mo1-aa092", "branch": "trunk", "revision": 340, "owner": "jim",
  "project": "var", "title": "6D Quantum VAR.", "status": "M ", 
  "location": "NAE"}]
      
</pre>
      </dd>

      <dd>
        <p>This returned all past and present suites that contained a match for
        at least one of the search terms. Older versions of suites appear, and
        you can also see a deleted suite (<samp>aa001</samp>).</p>
      </dd>
    </dl>

    <h2 id="library">Rose Python Modules</h2>

    <p>This gives some brief information about Rose python modules. For more
    information, see the files themselves.</p>

    <h3 id="library:rose">Rose Main Modules</h3>

    <p>This section describes the modules under the
    <code>lib/python/rose</code> package.</p>

    <dl>
      <dt><code>rose</code></dt>

      <dd>(<code>__init__.py</code>) stores some constants used by Rose
      programs.</dd>

      <dt><code>rose.ana</code></dt>

      <dd>callable, invokes an analysis engine for testing suites/apps.</dd>

      <dt><code>rose.config</code></dt>

      <dd>callable, parses and dumps rose configuration files. Contains the
      main configuration object <code>rose.config.ConfigNode</code> which is
      manipulated in most rose programs.</dd>

      <dt><code>rose.config_processor</code></dt>

      <dd>library, base class for rose configuration processing.</dd>

      <dt><code>rose.config_processors</code></dt>

      <dd>(package) subclasses for rose configuration processing.</dd>

      <dt><code>rose.env</code></dt>

      <dd>library, handles environment processing for
      <code>rose.app_run</code>.</dd>

      <dt><code>rose.external</code></dt>

      <dd>library, contains minimal wrapper functions for calling external
      programs.</dd>

      <dt><code>rose.formats</code></dt>

      <dd>(package) contains modules that deal with supported format parsing.
      The only current supported format is Fortran namelist, through
      <code>rose.formats.namelist</code>.</dd>

      <dt><code>rose.fs_util</code></dt>

      <dd>library, file system utilities with event reporting.</dd>

      <dt><code>rose.gtk</code></dt>

      <dd>(package) contains modules that deal with generic GTK operations and
      contain shared widgets.</dd>

      <dt><code>rose.host_select</code></dt>

      <dd>callable, ranks and selects host machines.</dd>

      <dt><code>rose.macro</code></dt>

      <dd>callable, runs internal and custom macros for an application or
      suite.</dd>

      <dt><code>rose.meta_type</code></dt>

      <dd>library, classes for the various metadata <code>type</code>
      groups.</dd>

      <dt><code>rose.metadata_gen</code></dt>

      <dd>callable, generates template metadata for an application.</dd>

      <dt><code>rose.namelist_dump</code></dt>

      <dd>callable, dumps namelist files to a Rose configuration object.</dd>

      <dt><code>rose.opt_parse</code></dt>

      <dd>library, contains an <code>optparse.OptionParser</code> subclass. All
      command-line option parsing in Rose should use this.</dd>

      <dt><code>rose.popen</code></dt>

      <dd>library, utilities for spawning and monitoring processes.</dd>

      <dt><code>rose.resource</code></dt>

      <dd>library, locates files or directories.</dd>

      <dt><code>rose.run</code></dt>

      <dd>callable, contains classes for running suites, applications, tasks
      and so on.</dd>

      <dt><code>rose.section</code></dt>

      <dd>library, contains section-specific data utilities. Counterpart of
      <code>rose.variable</code>.</dd>

      <dt><code>rose.stem</code></dt>

      <dd>callable, converts user-friendly options for testing code into
      options for rose suite-run.</dd>

      <dt><code>rose.suite_engine_proc</code></dt>

      <dd>library, base class and utilities for interacting with a suite
      engine.</dd>

      <dt><code>rose.suite_engine_procs</code></dt>

      <dd>(package) library for interacting with specific suite engines.</dd>

      <dt><code>rose.suite_control</code></dt>

      <dd>Invoke control commands (currently gcontrol and shutdown) of a
      running suite.</dd>

      <dt><code>rose.suite_hook</code></dt>

      <dd>callable, reacts to suite engine events.</dd>

      <dt><code>rose.suite_log_view</code></dt>

      <dd>callable, sets up suite output for the output viewer.</dd>

      <dt><code>rose.suite_scan</code></dt>

      <dd>callable, scans for running suites.</dd>

      <dt><code>rose.task_env</code></dt>

      <dd>callable, provides an environment for a suite task.</dd>

      <dt><code>rose.upgrade</code></dt>

      <dd>library, provides configuration upgrade functionality.</dd>

      <dt><code>rose.variable</code></dt>

      <dd>library, utilities for processing metadata and a basic data structure
      used by the config editor to hold values and metadata for options.</dd>
    </dl>

    <h3 id="library:rose:config_edit">Rose Config Editor Modules</h3>

    <p>This section describes the modules under the
    <code>lib/python/rose/config_editor</code> package. These are specific to
    the config editor.</p>

    <dl>
      <dt><code>rose.config_editor</code></dt>

      <dd>(<code>__init__.py</code>) stores some constants used for display in
      the config editor. All of these can be overridden using your user
      config.</dd>

      <dt><code>rose.config_editor.keywidget</code>,
      <code>rose.config_editor.menuwidget</code>,
      <code>rose.config_editor.pagewidget</code> (package),
      <code>rose.config_editor.variable</code>,
      <code>rose.config_editor.valuewidget</code> (package)</dt>

      <dd>These contain GTK code that control the adding/removing/modifying of
      options on a config editor tab. These can all be overridden using custom
      widgets (especially <code>rose.config_editor.valuewidget</code>
      modules).</dd>

      <dt><code>rose.config_editor.loader</code></dt>

      <dd>This controls the loading and retrieval of configuration data within
      the config editor.</dd>

      <dt><code>rose.config_editor.main</code></dt>

      <dd>This contains the centralised main control code of the config editor
      - updates, undo stack, etc.</dd>

      <dt><code>rose.config_editor.menu</code></dt>

      <dd>This module contains the menu for the config editor and various
      menu-related functions such as adding and removing sections.</dd>

      <dt><code>rose.config_editor.page</code></dt>

      <dd>This module contains control code for each config editor tab, and
      interfaces with <code>rose.config_editor.pagewidget</code> objects
      (including custom pages).</dd>

      <dt><code>rose.config_editor.panel</code></dt>

      <dd>This creates and alters the GTK Treeview panel of the config
      editor.</dd>

      <dt><code>rose.config_editor.stack</code></dt>

      <dd>This holds the <var>Undo</var> and <var>Redo</var> stack templates,
      and contains various functions to alter variables. This is the main
      functional interface for custom pages.</dd>

      <dt><code>rose.config_editor.util</code></dt>

      <dd>Various small utilities.</dd>

      <dt><code>rose.config_editor.window</code></dt>

      <dd>Creates the main GTK window of the config editor and provides
      functions to launch dialogs.</dd>
    </dl>

    <h3 id="library:rose:macros">Rose Built-in Macro Modules</h3>

    <p>The <code>lib/python/rose/macros</code> package contains built-in macros
    that perform checking against metadata. Most of these are run each time
    something changes in the config editor. They can be run on the command line
    via <code>rose macro</code>.</p>

    <dl>
      <dt><code>rose.macros.compulsory</code></dt>

      <dd>checks/fixes <var>compulsory</var> sections and options</dd>

      <dt><code>rose.macros.format</code></dt>

      <dd>checks format-specific sections and options, using options in
      <code>rose.formats</code> modules</dd>

      <dt><code>rose.macros.rule</code></dt>

      <dd>checks <var>fail-if</var> and <var>warn-if</var> metadata
      conditions</dd>

      <dt><code>rose.macros.trigger</code></dt>

      <dd>checks <var>trigger</var> validity and transforms configuration
      ignored states</dd>

      <dt><code>rose.macros.value</code></dt>

      <dd>checks <var>type</var>, <var>range</var>, <var>length</var>,
      <var>pattern</var>, or <var>values</var> metadata</dd>
    </dl>

    <h3 id="library:rosie">Rosie Modules</h3>

    <p>This section describes the modules under the
    <code>lib/python/rosie</code> package.</p>

    <dl>
      <dt><code>rosie.browser</code></dt>

      <dd>(package) GTK client code for rosie (<code>rosie go</code>).</dd>

      <dt><code>rosie.browser.history</code></dt>

      <dd>Methods and classes for recording suite search history. Used by
      <code>rosie go</code>.</dd>

      <dt><code>rosie.browser.main</code></dt>

      <dd>Main control code for <code>rosie go</code>.</dd>

      <dt><code>rosie.browser.result</code></dt>

      <dd>Custom widget with methods for displaying suite search results. Used
      by <code>rosie go</code>.</dd>

      <dt><code>rosie.browser.search</code></dt>

      <dd>Contains a wrapper class for running suite searches. Used by
      <code>rosie go</code>.</dd>

      <dt><code>rosie.browser.status</code></dt>

      <dd>Classes for getting and updating statuses for checked out suites.
      Used by <code>rosie go</code>.</dd>

      <dt><code>rosie.browser.suite</code></dt>

      <dd>Contains a wrapper class for handling the creation, copying, checking
      out and deleting of suites. Used by <code>rosie go</code>.</dd>

      <dt><code>rosie.browser.util</code></dt>

      <dd>Library of widgets for <code>rosie.browser</code>.</dd>

      <dt><code>rosie.db</code></dt>

      <dd>Interface code to the suite database, called by the web server.</dd>

      <dt><code>rosie.suite_id</code></dt>

      <dd>Callable, implements the <code>rosie id</code> command to identify
      suites.</dd>

      <dt><code>rosie.vc</code></dt>

      <dd>Interface code to version control.</dd>

      <dt><code>rosie.ws</code></dt>

      <dd>Rosie web server code.</dd>

      <dt><code>rosie.ws_client</code></dt>

      <dd>Interface to the Rosie web server. Used by <code>rosie query</code>,
      <code>rosie info</code>, <code>rosie search</code> and <code>rosie
      browse</code>.</dd>
    </dl>
  </div>
</body>
</html>
