<!DOCTYPE html>
<html>
<head>

  <title>Rose Reference Guide: API</title>
  <meta name="author" content="Rose Team, Met Office, UK" />
  <meta http-equiv="Content-Type" content=
  "text/html; charset=us-ascii" />
  <link rel="icon" href="img/rose-icon.png" type="image/png" />
  <link rel="shortcut icon" href="img/rose-icon.png" type=
  "image/png" />
  <link rel="stylesheet" type="text/css" href=
  "css/bootstrap.min.css" />
  <link rel="stylesheet" type="text/css" href="css/rose-doc.css" />
  <script type="text/javascript" src="js/jquery.min.js">
</script>
  <script type="text/javascript" src="js/run_prettify.js">
</script>
  <script type="text/javascript" src="js/prettify-rose-conf.js">
</script>
  <script type="text/javascript" src=
  "js/prettify-cylc-suite-rc.js">
</script>
  <script type="text/javascript" src="js/bootstrap.min.js">
</script>
  <script type="text/javascript" src="js/rose-doc.js">
</script>
  <script type="text/javascript" src="js/rose-version.js">
</script>
</head>

<body>
  <nav class="navbar navbar-default">
    <div class="container-fluid">
      <div class="navbar-header">
        <a class="navbar-brand" href="."><span class="logo">Rose
        Documentation</span></a>
      </div>
      <!-- Collect the nav links, forms, and other content for toggling -->

      <div class="collapse navbar-collapse" id=
      "bs-example-navbar-collapse-1">
        <ul class="nav navbar-nav">
          <li><a href="rose-single-page.html">Single Page
          Version</a></li>
        </ul>

        <ul class="nav navbar-nav navbar-right">
          <li><span class="navbar-text"><span class=
          "compliance">&#169; British Crown Copyright 2012-6
          <a href="http://www.metoffice.gov.uk">Met Office</a>. See
          <a href="rose-terms-of-use.html">Terms of Use</a>.<br />
          This document is released under the <a href=
          "http://www.nationalarchives.gov.uk/doc/open-government-licence/"
          rel="license">Open Government Licence</a>.</span></span></li>

          <li><span id="rose-version" class=
          "navbar-text"></span></li>
        </ul>
      </div><!-- /.navbar-collapse -->
    </div><!-- /.container-fluid -->
  </nav>

  <div class="container">
    <div class="row">
      <div class="col-md-12">
        <div id="panel-main" class="panel panel-default">
          <div class="panel-heading">
            <h1>Rose Reference Guide: API</h1>
          </div>

          <div id="body-main" class="panel-body">
            <div id="content"></div>

            <h2 id="intro">Introduction</h2>

            <p>Rose is mainly implemented in <a href=
            "http://www.python.org">Python</a> and <a href=
            "http://www.gnu.org/software/bash/">bash</a>.</p>

            <p>The sub-sections below explain how to make use of
            various application programming interfaces within Rose
            which are designed for extension. These are useful for
            extending Rose components or creating standalone
            programs that seek to manipulate Rose information.</p>

            <p>Most of these interfaces require a good knowledge of
            Python.</p>

            <h2 id="gtk">Rose GTK library</h2>

            <p>The Rose/Rosie GUIs (such as the config editor) are
            written using the Python bindings for the GTK GUI
            toolkit (<a href="http://www.pygtk.org">PyGTK</a>). You can
            write your own custom GTK widgets and use them within
            Rose. They should live with the metadata under the
            <code>lib/python/widget/</code> directory.</p>

            <h3 id="gtk:config-edit:values">Value Widgets</h3>

            <p>Value widgets are used for operating on the values
            of settings. In the config editor, they appear next to
            the menu button and name label. There are builtin value
            widgets in Rose such as text entry boxes, radio
            buttons, and drop-down menus. These are chosen by the
            config editor based on metadata - for example, if a
            setting has an integer type, the value widget will be a
            spin button.</p>

            <p>The config editor supports adding user-defined
            custom widgets which replace the default widgets. These
            have the same API, but live in the metadata directories
            rather than the Rose source code.</p>

            <p>For example, you may wish to add widgets that deal
            with dates (e.g. using something based on a <a href=
            "http://developer.gnome.org/pygtk/stable/class-gtkcalendar.html">
            calendar</a> widget) or use a <a href=
            "http://www.pygtk.org/pygtk2tutorial/sec-RangeWidgetEample.html">
            slider</a> widget for numbers. You may even want
            something that uses an image-based interface such as a
            latitude-longitude chooser based on a map.</p>

            <p>Normally, widgets will be placed within the metadata
            directory for the suite or application. Widgets going
            into the Rose core should be added to the
            <code>lib/python/rose/config_editor/valuewidget/</code>
            directory in a Rose distribution.</p>

            <h4 id="gtk:config-edit:values:example">Example</h4>

            <p>See the <a href=
            "rose-rug-advanced-tutorials-widget.html">Advanced
            Tutorial</a>.</p>

            <h4 id="gtk:config-edit:values:api">API Reference</h4>

            <p>All value widgets, custom or core, use the same API.
            This means that a good practical reference is the set
            of existing value widgets in the package
            <code>rose.config_editor.valuewidget</code>.</p>

            <p>The procedure for implementing a custom value widget
            is as follows:</p>

            <p>Assign a <var>widget[rose-config-edit]</var>
            attribute to the relevant variable in the metadata
            configuration, e.g.</p>
            <pre class="prettyprint lang-rose_conf">
[namelist:VerifConNL/ScalarAreaCodes]
widget[rose-config-edit]=module_name.AreaCodeChooser
</pre>

            <p>where the widget class lives in the module
            <var>module_name</var> under
            <code>lib/python/widget/</code> in the metadata
            directory for the application or suite. Modules are
            imported by the config editor on demand.</p>

            <p>This class should have a constructor of the form</p>
            <pre class="prettyprint">
class AreaCodeChooser(gtk.HBox):

    def __init__(self, value, metadata, set_value, hook, arg_str=None)
</pre>

            <p>with the following arguments</p>

            <dl>
              <dt><code>value</code></dt>

              <dd>a string that represents the value that the
              widget should display.</dd>

              <dt><code>metadata</code></dt>

              <dd>
                <p>a map or dictionary of configuration metadata
                properties for this value, such as</p>
                <pre class="prettyprint">
{'type': 'integer', 'help': 'This is used to count something'}
</pre>

                <p>You may not need to use this information.</p>
              </dd>

              <dt><code>set_value</code></dt>

              <dd>
                <p>a function that should be called with a new
                string value of this widget, e.g.</p>
                <pre class="prettyprint">
set_value("20")
</pre>
              </dd>

              <dt><code>hook</code></dt>

              <dd>
                <p>An instance of a class
                <code>rose.config_editor.valuewidget.ValueWidgetHook</code>
                containing callback functions that you should
                connect some of your widgets to.</p>
              </dd>

              <dt><code>arg_str</code></dt>

              <dd>
                <p>a keyword argument that stores extra text given
                to the <samp>widget</samp> option in the metadata,
                if any:</p>
                <pre class="prettyprint lang-rose_conf">
widget[rose-config-edit]=modulename.ClassName arg1 arg2 arg3 ...
</pre>

                <p>would give a <code>arg_str</code> of <code>"arg1
                arg2 arg3 ..."</code>. This could help configure
                your widget - for example, for a table based
                widget, you might give the column names</p>:
                <pre class="prettyprint lang-rose_conf">
widget[rose-config-edit]=table.TableValueWidget NAME ID WEIGHTING
</pre>This means that you can write a generic widget and then
configure it for different cases.
              </dd>
            </dl>

            <p><code>hook</code> contains some callback functions
            that you should implement:</p>

            <dl>
              <dt><code>hook.get_focus(widget) -&gt;
              None</code></dt>

              <dd>
                <p>which you should connect your top-level widget
                (<samp>self</samp>) to as follows:</p>
                <pre class="prettyprint">
    self.grab_focus = lambda: hook.get_focus(my_favourite_focus_widget)
</pre>

                <p>or define a method in your class</p>
                <pre class="prettyprint">
def grab_focus(self):
    """Override the focus method, so we can scroll to a particular widget."""
    return hook.get_focus(my_favourite_focus_widget)
</pre>

                <p>which allows the correct widget
                (<samp>my_favourite_focus_widget</samp>) in your
                container to receive the focus such as a gtk.Entry
                (<code>my_favourite_focus_widget</code>) and will
                also trigger a scroll action on a config editor
                page. This is important to implement to get the
                proper global find functionality.</p>
              </dd>

              <dt><code>hook.trigger_scroll(widget) -&gt;
              None</code></dt>

              <dd>
                <p>accessed by</p>
                <pre class="prettyprint">
    hook.trigger_scroll(my_favourite_focus_widget)
</pre>

                <p>This should be connected to the
                <code>focus-in-event</code> GTK signal of your
                top-level widget (<samp>self</samp>):</p>
                <pre class="prettyprint">
        self.entry.connect('focus-in-event',
                           hook.trigger_scroll)

</pre>

                <p>This also is used to trigger a config editor
                page scroll to your widget.</p>
              </dd>
            </dl>

            <p>You may implement the following optional methods for
            your widget, which help to preserve cursor position
            when a widget is refreshed:</p>

            <dl>
              <dt><code>set_focus_index(focus_index) -&gt;
              None</code></dt>

              <dd>
                <p>A method that takes a number as an argument,
                which is the current cursor position relative to
                the characters in the variable value:</p>
                <pre class="prettyprint">
def set_focus_index(self, focus_index):
    """Set the cursor position to focus_index."""
    self.entry.set_position(focus_index)
</pre>

                <p>For example, a <code>focus_index</code> of
                <samp>0</samp> means that your widget should set
                the cursor position to the beginning of the value.
                A <code>focus_index</code> of <samp>4</samp> for a
                variable value of <samp>Operational</samp> means
                that the cursor should be placed between the
                <samp>r</samp> and the <samp>a</samp>.</p>

                <p>This has no real meaning or importance for
                widgets that don't display editable text. If you do
                not supply this method, the config editor will
                attempt to do the right thing anyway.</p>
              </dd>

              <dt><code>get_focus_index() -&gt;
              focus_index</code></dt>

              <dd>
                <p>A method that takes no arguments and returns a
                number which is the current cursor position
                relative to the characters in the variable
                value:</p>
                <pre class="prettyprint">
def get_focus_index(self):
    """Return the cursor position."""
    return self.entry.get_position()
</pre>

                <p>This has no real meaning or importance for
                widgets that don't display editable text. If you do
                not supply this method, the config editor will
                guess the cursor position anyway, based on the last
                change to the variable value.</p>
              </dd>

              <dt><code>handle_type_error(is_in_error) -&gt;
              None</code></dt>

              <dd>
                <p>The default behaviour when a variable error is
                added or removed is to re-instantiate the widget
                (refresh and redraw it). This can be overridden by
                defining this method in your value widget class. It
                takes a boolean <code>is_in_error</code> which is
                <samp>True</samp> if there is a value (type) error
                and <samp>False</samp> otherwise:</p>
                <pre class="prettyprint">
def handle_type_error(self, is_in_error):
    """Change behaviour based on whether the variable is_in_error."""
    icon_id = gtk.STOCK_DIALOG_ERROR if is_in_error else None
    self.entry.set_icon_from_stock(0, gtk.STOCK_DIALOG_ERROR)
</pre>

                <p>For example, this is used in a built-in widget
                for the quoted string types <code>string</code> and
                <code>character</code>. The quotes around the text
                are normally hidden, but the
                <code>handle_type_error</code> shows them if there
                is an error. The method also keeps the keyboard
                focus, which is the main purpose.</p>

                <p>You may not have much need for this method, as
                the default error flagging and cursor focus
                handling is normally sufficient.</p>
              </dd>
            </dl>

            <p>All the existing variable value widgets are
            implemented using this API, so a good resource is the
            modules within the
            <samp>lib/python/rose/config_editor/valuewidget</samp>
            package.</p>

            <h3 id="gtk:config-edit:pages">Config Editor Custom
            Pages</h3>

            <p>A 'page' in the config editor is the container
            inside a tab or detached tab that (by default) contains
            a table of variable widgets. The config editor allows
            custom 'pages' to be defined that may or may not use
            the standard set of variable widgets (menu button,
            name, value widget). This allows any presentation of
            the underlying variable information.</p>

            <p>For example, you may wish to present the variables
            in a more structured, two-dimensional form rather than
            as a simple list. You may want to strip down or add to
            the information presented by default - e.g. hiding
            names or embedding widgets within a block of help
            text.</p>

            <p>You may even wish to do something off-the-wall such
            as an <a href=
            "http://code.google.com/p/jrfonseca/wiki/XDot">xdot-based</a>
            widget set!</p>

            <h4 id="gtk:config-edit:pages:api">API Reference</h4>

            <p>The procedure for generating a custom page widget is
            as follows:</p>

            <p>Assign a <code>widget</code> option to the relevant
            namespace in the metadata configuration, e.g.</p>
            <pre class="prettyprint lang-rose_conf">
    [ns:namelist/STASHNUM]
    widget[rose-config-edit]=module_name.MyGreatBigTable
</pre>

            <p>The widget class should have a constructor of the
            form</p>
            <pre class="prettyprint">
    class MyGreatBigTable(gtk.Table):

        def __init__(self, real_variable_list, missing_variable_list,
                     variable_functions_inst, show_modes_dict,
                     arg_str=None):
</pre>

            <p>The class can inherit from any
            <code>gtk.Container</code>-derived class.</p>

            <p>The constructor arguments are</p>

            <dl>
              <dt><code>real_variable_list</code></dt>

              <dd>a list of the Variable objects (x.name, x.value,
              x.metadata, etc from the rose.variable module). These
              are the objects you will need to generate your
              widgets around.</dd>

              <dt><code>missing_variable_list</code></dt>

              <dd>a list of 'missing' Variable objects that could
              be added to the container. You will only need to
              worry about these if you plan to show them by
              implementing the <code>'View Latent'</code> menu
              functionality that we'll discuss further on.</dd>

              <dt><code>variable_functions_inst</code></dt>

              <dd>an instance of the class
              rose.config_editor.ops.variable.VariableOperations.This
              contains methods to operate on the variables. These
              will update the undo stack and take care of any
              errors. These methods are the only ways that you
              should write to the variable states or values. For
              documentation, see the module
              lib/python/rose/config_editor/ops/variable.py.</dd>

              <dt><code>show_modes_dict</code></dt>

              <dd>
                a dictionary that looks like this:
                <pre class="prettyprint">
    show_modes_dict = {'latent': False, 'fixed': False, 'ignored': True,
                       'user-ignored': False, 'title': False,
                       'flag:optional': False, 'flag:no-meta': False}
</pre>

                <p>which could be ignored for most custom pages, as
                you need. The meaning of the different keys in a
                non-custom page is:</p>

                <dl>
                  <dt><code>'latent'</code></dt>

                  <dd>False means don't display widgets for
                  variables in the metadata or that have been
                  deleted (the <code>variable_list.ghosts</code>
                  variables)</dd>

                  <dt><code>'fixed'</code></dt>

                  <dd>False means don't display widgets for
                  variables if they only have one value set in the
                  metadata <code>values</code> option.</dd>

                  <dt><code>'ignored'</code></dt>

                  <dd>False means don't display widgets for
                  variables if they're ignored (in the
                  configuration, but commented out).</dd>

                  <dt><code>'user-ignored'</code></dt>

                  <dd>(If <code>ignored</code> is False) False
                  means don't display widgets for user-ignored
                  variables. True means always show user-ignored
                  variables.</dd>

                  <dt><code>'title'</code></dt>

                  <dd>Short for 'View with no title', False means
                  show the title of a variable, True means show the
                  variable name instead.</dd>

                  <dt><code>'flag:optional'</code></dt>

                  <dd>True means indicate if a variable is
                  <code>optional</code>, and False means do not
                  show an indicator.</dd>

                  <dt><code>'flag:no-meta'</code></dt>

                  <dd>True means indicate if a variable has any
                  metadata content, and False means do not show an
                  indicator.</dd>
                </dl>

                <p>If you wish to implement actions based on
                changes in these properties (e.g. displaying and
                hiding fixed variables depending on the 'fixed'
                setting), the custom page widget should expose a
                method named 'show_mode_change' followed by the
                key. However, 'ignored' is handled separately (more
                below). These methods should take a single boolean
                that indicates the display status. For example:</p>
                <pre class="prettyprint">
def show_fixed(self, should_show)
</pre>

                <p>The argument <code>should_show</code> is a
                boolean. If True, fixed variables should be shown.
                If False, they should be hidden by your custom
                container.</p>
              </dd>

              <dt><code>arg_str</code></dt>

              <dd>
                <p>a keyword argument that stores extra text given
                to the <samp>widget</samp> option in the metadata,
                if any:</p>
                <pre class="prettyprint lang-rose_conf">
widget[rose-config-edit] = modulename.ClassName arg1 arg2 arg3 ...
</pre>

                <p>would give a <code>arg_str</code> of <code>"arg1
                arg2 arg3 ..."</code>. This could help configure
                your widget - for example, for a table based
                widget, you might give the column names</p>:
                <pre class="prettyprint lang-rose_conf">
widget[rose-config-edit] = table.TableValueWidget NAME ID WEIGHTING
</pre>This means that you can write a generic widget and then
configure it for different cases.
              </dd>
            </dl>

            <p>Refreshing the whole page in order to display a
            small change to a variable (the default) can be
            undesirable. To deal with this, custom page widgets can
            optionally expose some variable-change specific methods
            that do this themselves. These take a single
            rose.variable.Variable instance as an argument.</p>

            <dl>
              <dt><code>def add_variable_widget(self, variable)
              -&gt; None</code></dt>

              <dd>will be called when a variable is created.</dd>

              <dt><code>def reload_variable_widget(self, variable)
              -&gt; None</code></dt>

              <dd>will be called when a variable's status is
              changed, e.g. it goes into an error state.</dd>

              <dt><code>def remove_variable_widget(self, variable)
              -&gt; None</code></dt>

              <dd>will be called when a variable is removed.</dd>

              <dt><code>def update_ignored(self) -&gt;
              None</code></dt>

              <dd>will be called to allow you to update ignored
              widget display, if (for example) you show/hide
              ignored variables. If you don't have any custom
              behaviour for ignored variables, it's worth writing a
              method that does nothing - e.g. one that contains
              just <code>pass</code>).</dd>
            </dl>

            <p>If you take the step of using your own variable
            widgets, rather than the VariableWidget class in
            lib/python/rose/config_editor/variable.py (the default
            for normal config-edit pages), each variable-specific
            widget should have an attribute <code>variable</code>
            set to their rose.variable.Variable instance. You can
            implement 'ignored' status display by giving the widget
            a method <code>set_ignored</code> which takes no
            arguments. This should examine the
            <code>ignored_reason</code> dictionary attribute of the
            widget's <code>variable</code> instance - the variable
            is ignored if this is not empty. If the variable is
            ignored, the widget should indicate this e.g. by
            greying out part of it.</p>

            <p>All existing page widgets use this API, so a good
            resource is the modules in
            <samp>lib/python/rose/config_editor/pagewidget/</samp>.</p>

            <p>Generally speaking, a visible change, click, or key
            press in the custom page widget should make instant
            changes to variable value(s), and the value that the
            user sees. Pages are treated as temporary, superficial
            views of variable data, and changes are always assumed
            to be made directly to the main copy of the
            configuration in memory (this is automatic when the
            rose.config_editor.ops.variable.VariableOperations
            methods are used, as they should be). Closing the page
            shouldn't change, or lose, any data! The custom class
            should return a gtk object to be packed into the page
            framework, so it's best to subclass from an existing
            gtk Container type such as gtk.VBox (or gtk.Table, in
            the example above).</p>

            <p>In line with the general philosophy, metadata should
            not be critical to page operations - it should be
            capable of displaying variables even when they have no
            or very little metadata, and still make sense if some
            variables are missing or new.</p>

            <h3 id="gtk:config-edit:sub-panel">Config Editor Custom
            Sub Panels</h3>

            <p>A 'sub panel' or 'summary panel' in the config
            editor is a panel that appears at the bottom of a page
            and is intended to display some summarised information
            about sub-pages (sub-namespaces) underneath the page.
            For example, the top-level file page, by default, has a
            sub panel to summarise the individual file
            sections.</p>

            <p>Any actual data belonging to the page will appear
            above the sub panel in a separate representation.</p>

            <p>Sub panels are capable of using quite a lot of
            functionality such as modifying the sections and
            options in the sub-pages directly.</p>

            <h4 id="gtk:config-edit:sub-panel:api">API
            Reference</h4>

            <p>The procedure for generating a custom sub panel
            widget is as follows:</p>

            <p>Assign a
            <code>widget[rose-config-edit:sub-ns]</code> option to
            the relevant namespace in the metadata configuration,
            e.g.</p>
            <pre class="prettyprint lang-rose_conf">
    [ns:namelist/all_the_foo_namelists]
    widget[rose-config-edit:sub-ns]=module_name.MySubPanelForFoos
</pre>

            <p>Note that because the actual data on the page has a
            separate representation, you need to write
            <samp>[rose-config-edit:sub-ns]</samp> rather than just
            <samp>[rose-config-edit]</samp>.</p>

            <p>The widget class should have a constructor of the
            form</p>
            <pre class="prettyprint">
    class MySubPanelForFoos(gtk.VBox):

        def __init__(self, section_dict, variable_dict,
                     section_functions_inst, variable_functions_inst,
                     search_for_id_function, sub_functions_inst,
                     is_duplicate_boolean, arg_str=None):
</pre>

            <p>The class can inherit from any
            <code>gtk.Container</code>-derived class.</p>

            <p>The constructor arguments are:</p>

            <dl>
              <dt><code>section_dict</code></dt>

              <dd>a dictionary (map, hash) of section name keys and
              section data object values (instances of the
              <code>rose.section.Section</code> class). These
              contain some of the data such as section ignored
              status and comments that you may want to present.
              These objects can usually be used by the
              <code>section_functions_inst</code> methods as
              arguments - for example, passed in in order to ignore
              or enable a section.</dd>

              <dt><code>variable_dict</code></dt>

              <dd>a dictionary (map, hash) of section name keys and
              lists of variable data objects (instances of the
              <code>rose.variable.Variable</code> class). These
              contain useful information for the variable (option)
              such as state, value, and comments. Like section data
              objects, these can usually be used as arguments to
              the <code>variable_functions_inst</code> methods to
              accomplish things like changing a variable value or
              adding or removing a variable.</dd>

              <dt><code>section_functions_inst</code></dt>

              <dd>an instance of the class
              rose.config_editor.ops.section.SectionOperations.
              This contains methods to operate on the variables.
              These will update the undo stack and take care of any
              errors. Together with
              <code>sub_functions_inst</code>, these methods are
              the only ways that you should write to the section
              states or other attributes. For documentation, see
              the module
              lib/python/rose/config_editor/ops/section.py.</dd>

              <dt><code>variable_functions_inst</code></dt>

              <dd>an instance of the class
              rose.config_editor.ops.variable.VariableOperations.
              This contains methods to operate on the variables.
              These will update the undo stack and take care of any
              errors. These methods are the only ways that you
              should write to the variable states or values. For
              documentation, see the module
              lib/python/rose/config_editor/ops/variable.py.</dd>

              <dt><code>search_for_id_function</code></dt>

              <dd>a function that accepts a setting id (a section
              name, or a variable id) as an argument and asks the
              config editor to navigate to the page for that
              setting. You could use this to allow a click on a
              section name in your widget to launch the page for
              the section.</dd>

              <dt><code>sub_functions_inst</code></dt>

              <dd>an instance of the class
              rose.config_editor.ops.group.SubDataOperations. This
              contains some convenience methods specifically for
              sub panels, such as operating on many sections at
              once in an optimised way. For documentation, see the
              module
              lib/python/rose/config_editor/ops/group.py.</dd>

              <dt><code>is_duplicate_boolean</code></dt>

              <dd>a boolean that denotes whether or not the
              sub-namespaces in the summary data consist only of
              duplicate sections (e.g. only
              <samp>namelist:foo(1)</samp>,
              <samp>namelist:foo(2)</samp>, ...). For example, this
              could be used by your widget to decide whether to
              implement a <q>Copy section</q> user option.</dd>

              <dt><code>arg_str</code></dt>

              <dd>
                <p>a keyword argument that stores extra text given
                to the <samp>widget</samp> option in the metadata,
                if any - e.g.:</p>
                <pre class="prettyprint lang-rose_conf">
widget[rose-config-edit:sub-ns] = modulename.ClassName arg1 arg2 arg3 ...
</pre>

                <p>would give a <code>arg_str</code> of <code>"arg1
                arg2 arg3 ..."</code>. You can use this to help
                configure your widget.</p>
              </dd>
            </dl>

            <p>All existing sub panel widgets use this API, so a
            good resource is the modules in
            <samp>lib/python/rose/config_editor/panelwidget/</samp>.</p>

            <h2 id="macro">Rose Macros</h2>

            <p>Rose macros manipulate or check configurations,
            often based on their metadata. There are four types of
            macros:</p>

            <ul>
              <li>Checkers (validators) - check a configuration,
              perhaps using metadata.</li>

              <li>Changers (transformers) - change a configuration
              e.g. adding/removing options.</li>

              <li>Upgraders - these are special transformer macros
              for upgrading and downgrading configurations. (covered in the
              <a href="#upgrade">next section</a>)</li>

              <li>Reporters - output information about a
              configuration.</li>
            </ul>

            <p>There are built-in rose macros that handle standard
            behaviour such as trigger changing and type
            checking.</p>

            <p>This section explains how to add your own custom
            macros to transform and validate configurations. See
            <a href="#upgrade">Upgrade Macro API</a> for upgrade
            macros.</p>

            <p>Macros use a Python API, and should be written in
            Python, unless you are doing something very fancy. In
            the absence of a Python house style, it's usual to
            follow the standard Python style guidance (<a href=
            "http://www.python.org/dev/peps/pep-0008/">PEP8</a>,
            <a href=
            "http://www.python.org/dev/peps/pep-0257/">PEP257</a>).</p>

            <p>They can be run within <code>rose config-edit</code>
            or via <code>rose macro.</code></p>

            <p>You should avoid writing checker macros if the
            checking can be expressed via metadata.</p>

            <h3 id="macro:location">Location</h3>

            <p>A module containing macros should be stored under a
            directory <code>lib/python/macros/</code> in the
            metadata for a configuration. This directory should be
            a Python package.</p>

            <p>When developing macros for Rose internals, macros
            should be placed in the <code>rose.macros</code>
            package in the Rose Python library. They should be
            referenced by the
            <code>lib/python/rose/macros/__init__.py</code> classes
            and a call to them can be added in the
            <code>lib/python/rose/config_editor/main.py</code>
            module if they need to be run implicitly by the config
            editor.</p>

            <h3 id="macro:code">Code</h3>

            <h4 id="macro:code:examples">Examples</h4>

            <p>See the macro <a href=
            "rose-rug-advanced-tutorials-macro.html">Advanced
            Tutorial</a>.</p>

            <h4 id="macro:code:api:docs">API Documentation</h4>
            <p>The <code>rose.macro.MacroBase</code> class (subclassed by all
            rose macros) is documented <a
              href="sphinx/_build/html/macro.html">here</a>.

            <h4 id="macro:code:api">API Reference</h4>

            <p>Validator, transformer and reporter macros are
            python classes which subclass from
            <code>rose.macro.MacroBase</code> (<a
              href="sphinx/_build/html/macro.html">api docs</a>).

            <p>These macros implement their behaviours by providing a
            <code>validate</code>, <code>transform</code> or
            <code>report</code> method. A macro can contain any
            combination of these methods so, for example, a macro
            might be both a validator and a transformer.</p>

            <p>These methods should accept two
            <code>rose.config.ConfigNode</code> (<a
              href="sphinx/_build/html/config.html">api docs</a>)
            instances as arguments - one is the configuration, and
            one is the metadata configuration that provides
            information about the configuration items.</p>

            <p>A validator macro should look like:</p>
            <pre class="prettyprint">
import rose.macro

class SomeValidator(rose.macro.MacroBase):

    """This does some kind of check."""

    def validate(self, config, meta_config=None):
        # Some check on config appends to self.reports using self.add_report
        return self.reports
</pre>

            <p>The returned list should be a list of
            rose.macro.MacroReport objects containing the section,
            option, value, and warning strings for each setting
            that is in error. These are initialised behind the
            scenes by calling the inherited method
            <code>rose.macro.MacroBase.add_report</code> via
            <code>self.add_report</code>. This has the form:</p>
            <pre class="prettyprint">
    def add_report(self, section=None, option=None, value=None, info=None,
                   is_warning=False):
</pre>

            <p>This means that you should call it with the relevant
            section first, then the relevant option, then the
            relevant value, then the relevant error message, and
            optionally a warning flag that we'll discuss later. If
            the setting is a section, the option should be
            <code>None</code> and the value None. For example,</p>
            <pre class="prettyprint">
    def validate(self, config, meta_config=None):
        editor_value = config.get(["env", "MY_FAVOURITE_STREAM_EDITOR"]).value
        if editor_value != "sed":
            self.add_report("env",                         # Section
                            "MY_FAVOURITE_STREAM_EDITOR",  # Option
                            editor_value,                  # Value
                            "Should be 'sed'!")            # Message
        return self.reports
</pre>

            <p>Validator macros have the option to give warnings,
            which do not count as formal errors in the Rose config
            editor GUI. These should be used when something
            <em>may</em> be wrong, such as warning when using an
            advanced-developer-only option. They are invoked by
            passing a 5th argument to <code>self.add_report</code>,
            <code>is_warning</code>, like so:</p>
            <pre class="prettyprint">
            self.add_report("env",
                            "MY_FAVOURITE_STREAM_EDITOR",
                            editor_value,
                            "Could be 'sed'",
                            is_warning=True)
</pre>

            <p>A transformer macro should look like:</p>
            <pre class="prettyprint">
import rose.macro

class SomeTransformer(rose.macro.MacroBase):

    """This does some kind of change to the config."""

    def transform(self, config, meta_config=None):
        # Some operation on config which calls self.add_report for each change.
        return config, self.reports
</pre>

            <p>The returned list should be a list of 4-tuples
            containing the section, option, value, and information
            strings for each setting that was changed (e.g. added,
            removed, value changed). If the setting is a section,
            the option should be <code>None</code> and the value
            None. If an option was removed, the value should be the
            old value - otherwise it should be the new one
            (added/changed). For example,</p>
            <pre class="prettyprint">
    def transform(self, config, meta_config=None):
        """Add some more snow control."""
        if config.get(["namelist:snowflakes"]) is None:
            config.set(["namelist:snowflakes"])
            self.add_report(list_of_changes,
                            "namelist:snowflakes", None, None,
                            "Updated snow handling in time for Christmas")
            config.set(["namelist:snowflakes", "l_unique"], ".true.")
            self.add_report("namelist:snowflakes", "l_unique", ".true.",
                            "So far, anyway.")
        return config, self.reports
</pre>

            <p>The current working directory within a macro is
            always the configuration's directory. This makes it
            easy to access non-<samp>rose-app.conf</samp> files
            (e.g. in the <samp>file/</samp> subdirectory).</p>

            <p>There are also reporter macros which can be used
            where you need to output some information about a
            configuration. A reporter macro takes the same form
            as validator and transform macros but does not require
            a return value.</p>

            <pre class="prettyprint">
    def report(self, config, meta_config=None):
        """ Write some information about the configuration to a report file."""
        # Note: report methods do not have a return value.
        with open('report/file', 'r') as report_file:
            report_file.write(str(config.get(["namelist:snowflakes"])))
</pre>

            <p>Macros also support the use of keyword arguments,
            giving you the ability to have the user specify some
            input or override to your macro. For example a
            transformer macro could be written as follows to allow
            the user to input <code>some_value</code>:</p>
            <pre class="prettyprint">
    def transform(self, config, meta_config=None, some_value=None):
        """Some transformer macro"""
        return
</pre>

            <p>Note that the extra arguments require default values
            (<code>=None</code> in this example) and that you
            should add error handling for the input
            accordingly.</p>

            <p>On running your macro the user will be prompted to
            supply values for these arguments or accept the default
            values.</p>

            <h2 id="upgrade">Rose Upgrade Macros</h2>

            <p>Rose upgrade macros are used to upgrade application
            configurations between metadata versions. They are
            classes, very similar to the Transform macros above,
            but with a few differences:</p>

            <ul>
              <li>an <var>upgrade</var> method instead of a
              <var>transform</var> method</li>

              <li>an optional <var>downgrade</var> method,
              identical in API to the <var>upgrade</var> method,
              but intended for performing the reverse
              operation</li>

              <li>a more helpful API via
              <code>rose.upgrade.MacroUpgrade</code> methods</li>

              <li><samp>BEFORE_TAG</samp> and
              <samp>AFTER_TAG</samp> attributes - the version of
              metadata they apply to (<samp>BEFORE_TAG</samp>) and
              the version they upgrade to
              (<samp>AFTER_TAG</samp>)</li>
            </ul>

            <p>An example upgrade macro might look like this:</p>
            <pre class="prettyprint">
class Upgrade272to273(rose.upgrade.MacroUpgrade):

    """Upgrade from 27.2 to 27.3."""

    BEFORE_TAG = "27.2"
    AFTER_TAG = "27.3"

    def upgrade(self, config, meta_config=None):
        self.add_setting(config, ["env", "NEW_VARIABLE"], "0")
        self.remove_setting(config, ["namelist:old_things", "OLD_VARIABLE"])
        return config, self.reports
</pre>

            <p>The class name is unimportant - the
            <samp>BEFORE_TAG</samp> and <samp>AFTER_TAG</samp>
            identify the macro.</p>

            <p>Metadata versions are usually structured in a
            <samp>rose-meta/CATEGORY/VERSION/</samp> hierarchy -
            where <samp>CATEGORY</samp> denotes the type or family
            of application (sometimes it is the command used), and
            <samp>VERSION</samp> is the particular version e.g.
            <samp>27.2</samp> or <samp>HEAD</samp>.</p>

            <p>Upgrade macros live under the <samp>CATEGORY</samp>
            directory in a <samp>versions.py</samp> file -
            <samp>rose-meta/CATEGORY/versions.py</samp>.</p>

            <p>If you have many upgrade macros, you may want to
            separate them into different modules in the same
            directory. You can then import from those in
            <samp>versions.py</samp>, so that they are still
            exposed in that module. You'll need to make your
            directory a package by creating an
            <samp>__init__.py</samp> file, which should contain the
            line <samp>import versions</samp>. To avoid conflict
            with other <samp>CATEGORY</samp> upgrade modules (or
            other Python modules), please name these very modules
            carefully or use absolute or package level imports like
            this: <samp>from .versionXX_YY import
            FooBar</samp>.</p>

            <p>Upgrade macros are subclasses of
            <code>rose.upgrade.MacroUpgrade</code>. They have all
            the functionality of the transform macros documented
            above. <code>rose.upgrade.MacroUpgrade</code> also has
            some additional convenience methods defined for you to
            call. All methods return <code>None</code> unless
            otherwise specified.</p>

            <dl>
              <dt><code>def act_from_files(self, config,
              downgrade=False)</code></dt>

              <dd>
                <p>A method that takes the app configuration
                (<samp>config</samp>, a
                <code>rose.config.ConfigNode</code> instance) and
                an optional boolean <samp>downgrade</samp> keyword
                argument. This initiates a search for
                <samp>etc/VERSION/rose-macro-add.conf</samp> and
                <samp>etc/VERSION/rose-macro-remove.conf</samp>,
                where VERSION is equal to the
                <samp>BEFORE_TAG</samp> of the macro. These files
                should be Rose app config-like patch files,
                containing settings to be added
                (<samp>rose-macro-add.conf</samp>) and settings to
                be removed (<samp>rose-macro-remove.conf</samp>).
                If downgrading (<samp>downgrade</samp> set to
                <samp>True</samp>), the settings in
                <samp>rose-macro-remove.conf</samp> will be added,
                and the ones in <samp>rose-macro-add.conf</samp>
                removed.</p>
                <pre class="prettyprint">
    def upgrade(self, config, meta_config=None):
        self.act_from_files(config)
        return config, self.reports
</pre>

                <p>Note that you can use other methods (below) as
                well as this in the same <samp>upgrade</samp>.</p>

                <p>If settings are defined in either file, and
                changes can be made, the <code>self.reports</code>
                will be updated automatically.</p>
              </dd>

              <dt><code>def add_setting(self, config, keys,
              value=None, forced=False, state=None, comments=None,
              info=None):</code></dt>

              <dd>
                <p>A method that attempts to add the setting
                defined by the list <samp>keys</samp>
                (<samp>[section]</samp> or <samp>[section,
                option]</samp> strings) with the value
                <samp>value</samp> to the app config
                <samp>config</samp>. The arguments mostly follow
                <code>rose.config.ConfigNode</code> attributes, and
                are as follows:</p>

                <dl>
                  <dt><samp>config</samp></dt>

                  <dd>The application configuration object
                  (<code>rose.config.ConfigNode</code>
                  instance)</dd>

                  <dt><samp>keys</samp></dt>

                  <dd>A list of strings denoting config settings -
                  <code>[section_name]</code> for a section,
                  <code>[section_name, option_name]</code> for an
                  option. For example, it might be
                  <code>["namelist:foo", "bar"]</code>.</dd>

                  <dt><samp>value</samp> (optional)</dt>

                  <dd>A string or <code>None</code> denoting the
                  new setting value. <code>None</code> should be
                  used for sections only. Options must have a
                  string <code>value</code> defined.</dd>

                  <dt><samp>forced</samp> (optional)</dt>

                  <dd>If the setting already exists, override the
                  value to the new <code>value</code>.</dd>

                  <dt><samp>state</samp> (optional)</dt>

                  <dd>Set the state of the new setting
                  (<code>rose.config.ConfigNode</code> states) -
                  <code>None</code> implies the default, which is
                  <code>rose.config.ConfigNode.STATE_NORMAL</code>.
                  You may also use
                  <code>rose.config.ConfigNode.STATE_USER_IGNORED.</code></dd>

                  <dt><samp>comments</samp> (optional)</dt>

                  <dd>A list of comment strings (lines) for the new
                  setting or <code>None</code>.</dd>

                  <dt><samp>info</samp> (optional)</dt>

                  <dd>A short string containing no new lines,
                  describing the addition of the setting.</dd>
                </dl>
              </dd>

              <dd>
                <p>Example usage:</p>
                <pre class="prettyprint">
    def upgrade(self, config, meta_config=None):
        self.add_setting(config, ["namelist:breakfast_nl", "bacon"], "2",
                         comments=["Mmmm. Bacon."], info="Add for food:#810")
        return config, self.reports
</pre>
              </dd>

              <dt><code>def change_setting_value(self, config,
              keys, value, forced=False, comments=None,
              info=None):</code></dt>

              <dd>
                <p>A method that attempts to change an existing
                setting value defined by <samp>keys</samp> to a new
                one (<samp>value</samp>) in the app config
                <samp>config</samp>. The arguments are:</p>

                <dl>
                  <dt><samp>config</samp>, <samp>keys</samp>,
                  <samp>comments</samp>, <samp>info</samp></dt>

                  <dd>As in <code>add_setting</code> above.</dd>

                  <dt><samp>value</samp></dt>

                  <dd>Required argument, must be a string for
                  option values, and can be <code>None</code> for
                  section values.</dd>

                  <dt><samp>forced</samp> (optional)</dt>

                  <dd>Add the setting if it does not exist.</dd>
                </dl>

                <p>Example usage:</p>
                <pre class="prettyprint">
    def upgrade(self, config, meta_config=None):
        self.change_setting_value(config, ["namelist:breakfast_nl", "coffee"], "'more'",
                                  info="Add for food:#820")
        return config, self.reports
</pre>
              </dd>

              <dt><code>def get_setting_value(self, config, keys,
              no_ignore=False): (-&gt; value)</code></dt>

              <dd>
                <p>A method that returns a setting value or
                <code>None</code>, functionally similar to
                <code>rose.config.ConfigNode.get</code>. The
                arguments are:</p>

                <dl>
                  <dt><samp>config</samp>, <samp>keys</samp></dt>

                  <dd>
                    <p>As in <code>add_setting</code> above.</p>
                  </dd>

                  <dt><samp>no_ignore</samp> (optional)</dt>

                  <dd><code>False</code> means return the setting
                  value if the setting is ignored.
                  <code>True</code> means return <code>None</code>
                  if the setting is ignored. If the setting is
                  missing, <code>None</code> is returned.</dd>
                </dl>

                <p>Example usage:</p>
                <pre class="prettyprint">
    def upgrade(self, config, meta_config=None):
        if self.get_setting_value(
                    config, ["namelist:breakfast_nl", "coffee"]) == "'empty'":
            self.add_setting(config, ["namelist:breakfast_nl", "tea"],
                             "'extra_strong'")
        return config, self.reports
</pre>
              </dd>

              <dt><code>def remove_setting(self, config, keys,
              info=None):</code></dt>

              <dd>
                <p>A method that removes a setting defined by
                <samp>keys</samp> in <samp>config</samp> with an
                optional <samp>info</samp> message. The arguments
                are:</p>

                <dl>
                  <dt><samp>config</samp>, <samp>keys</samp>,
                  <samp>info</samp></dt>

                  <dd>As in <code>add_setting</code> above.</dd>
                </dl>

                <p>Example usage:</p>
                <pre class="prettyprint">
    def upgrade(self, config, meta_config=None):
        self.remove_setting(config, ["namelist:breakfast_nl", "cheeseburger"],
                            info="Cheeseburgers are for lunch")
        return config, self.reports
</pre>

                <p>Example of removing an entire namelist:</p>
                <pre class="prettyprint">
    def upgrade(self, config, meta_config=None):
        self.remove_setting(config, ["namelist:breakfast_nl"],
                            info="We don't serve breakfast anymore")
        return config, self.reports
</pre>
              </dd>

              <dt><code>def rename_setting(self, config, keys,
              new_keys, info=None):</code></dt>

              <dd>
                <p>A method that attempts to rename the setting
                defined by the list <samp>keys</samp>
                (<samp>[section]</samp> or <samp>[section,
                option]</samp> strings) to the new name defined by
                <samp>new_keys</samp>. The arguments mostly follow
                <code>rose.config.ConfigNode</code> attributes, and
                are as follows:</p>

                <dl>
                  <dt><samp>config</samp></dt>

                  <dd>The application configuration object
                  (<code>rose.config.ConfigNode</code>
                  instance)</dd>

                  <dt><samp>keys</samp></dt>

                  <dd>A list of strings denoting config settings -
                  <code>[section_name]</code> for a section,
                  <code>[section_name, option_name]</code> for an
                  option. For example, it might be
                  <code>["namelist:foo", "bar_old"]</code>.</dd>

                  <dt><samp>new_keys</samp></dt>

                  <dd>A list of strings denoting config settings -
                  <code>[section_name]</code> for a section,
                  <code>[section_name, option_name]</code> for an
                  option. For example, it might be
                  <code>["namelist:foo", "bar_new"]</code>.</dd>

                  <dt><samp>info</samp> (optional)</dt>

                  <dd>A short string containing no new lines,
                  describing the renaming of the setting.</dd>
                </dl>
              </dd>

              <dd>
                <p>Example usage:</p>
                <pre class="prettyprint">
    def upgrade(self, config, meta_config=None):
        self.rename_setting(config, ["namelist:breakfast_nl", "bad_coffee"],
                            ["namelist:breakfast_nl", "good_coffee"],
                            info="Mmmm... nicer coffee...")
        return config, self.reports
</pre>
              </dd>

              <dt><code>def enable_setting(self, config, keys,
              info=None):</code></dt>

              <dd>
                <p>A method to make sure a setting defined by
                <samp>keys</samp> in <samp>config</samp> is not
                user-ignored. The arguments are:</p>

                <dl>
                  <dt><samp>config</samp>, <samp>keys</samp>,
                  <samp>info</samp></dt>

                  <dd>As in <code>add_setting</code> above.</dd>
                </dl>

                <p>Example usage:</p>
                <pre class="prettyprint">
    def upgrade(self, config, meta_config=None):
        self.enable_setting(config, ["namelist:breakfast_nl", "egg_monitoring"])
        return config, self.reports
</pre>
              </dd>

              <dt><code>def ignore_setting(self, config, keys,
              info=None,
              state=rose.config.ConfigNode.STATE_USER_IGNORED):</code></dt>

              <dd>
                <p>Inverse of <code>enable_setting</code>, a method
                to make sure a setting defined by <samp>keys</samp>
                in <samp>config</samp> is ignored (default state is
                user-ignored). The arguments are:</p>

                <dl>
                  <dt><samp>config</samp>, <samp>keys</samp>,
                  <samp>info</samp></dt>

                  <dd>As in <code>add_setting</code> above.</dd>

                  <dt><samp>state</samp></dt>

                  <dd>One of
                  <code>rose.config.ConfigNode.STATE_USER_IGNORED</code>
                  (default),
                  <code>rose.config.ConfigNode.STATE_SYST_IGNORED</code>
                  (trigger-ignored). When using it, you can just
                  use <code>config.STATE...</code> rather than the
                  full
                  <code>rose.config.ConfigNode.STATE...</code>.</dd>
                </dl>

                <p>Example usage:</p>
                <pre class="prettyprint">
    def upgrade(self, config, meta_config=None):
        self.ignore_setting(config, ["namelist:breakfast_nl", "milk_bottle_date"])
        return config, self.reports
</pre>
              </dd>
            </dl>

            <p>There is an upgrade macro <a href=
            "rose-rug-advanced-tutorials-upgrade-dev.html">development
            tutorial</a> and more examples in the upgrade file for
            the upgrade <a href=
            "rose-rug-advanced-tutorials-upgrade-usage.html">usage
            tutorial</a> (<samp>versions.py</samp>), at
            <samp>$ROSE_HOME/etc/rose-meta/rose-demo-upgrade/versions.py</samp>,
            where <samp>$ROSE_HOME</samp> is the path to your local
            Rose distribution, locatable by invoking <code>rose
            --version</code>.</p>

            <h2 id="rosie-ws">Rosie Web</h2>

            <p>This section explains how to use the Rosie web
            service API. All Rosie discovery services (e.g.
            <code>rosie search</code>, <code>rosie go</code>, web
            page) use a <a href=
            "http://en.wikipedia.org/wiki/Representational_state_transfer">
            RESTful</a> API to interrogate a web server, which then
            interrogates an <a href=
            "http://www.planetofcoders.com/rdbms/">RDBMS</a>. Returned
            data is encoded in the <a href=
            "http://www.json.org/">JSON</a> format.</p>

            <p>You may wish to utilise the Python class
            <code>rosie.ws_client.Client</code> as an alternative
            to this API.</p>

            <h3 id="rosie-ws:location">Location</h3>

            <p>The URLs to access the web API of a Rosie web
            service (with a given prefix name) can be found in your
            rose site configuration file as the value of
            <var>[rosie-id]prefix-ws.PREFIX_NAME</var>. To access
            the API for a given repository with prefix PREFIX_NAME,
            you must select a format (the only currently supported
            format is 'json') and use a url that looks like:</p>
            <pre>
http://host/PREFIX_NAME/get_known_keys?format=json
</pre>

            <h3 id="rosie-ws:usage">Usage</h3>The API contains the
            following methods:

            <dl>
              <dt><code>get_known_keys</code></dt>

              <dd>
                returns the main property names stored for suites
                (e.g. idx, branch, owner) plus any additional names
                specified in the site config and takes the format
                argument. For example, entering a URL in a web
                browser:
                <pre>
http://host/PREFIX_NAME/get_known_keys?format=json
</pre>

                <p>may give</p>
                <pre class="prettyprint">
["access-list", "idx", "branch", "owner", "project", "revision", "status",  "title"]
</pre>
              </dd>

              <dt><code>get_optional_keys</code></dt>

              <dd>
                returns all unique optional or user-defined
                property names given in suite discovery information
                and takes the format argument. For example,
                entering this URL in Firefox:
                <pre>
http://host/PREFIX_NAME/get_optional_keys?format=json
</pre>

                <p>may give</p>
                <pre class="prettyprint">
["access-list", "description", "endgame_status", "operational_flag", "tag-list"]
</pre>
              </dd>

              <dt><code>get_query_operators</code></dt>

              <dd>
                returns all the SQL-like operators used to compare
                column values that you may use in queries (below)
                (e.g. <samp>eq</samp>, <samp>ne</samp>,
                <samp>contains</samp>, <samp>like</samp>) and takes
                the format argument. For example, entering this URL
                in a web browser:
                <pre>
http://host/PREFIX_NAME/get_query_operators?format=json
</pre>

                <p>may give</p>
                <pre class="prettyprint">
["eq", "ge", "gt", "le", "lt", "ne", "contains", "endswith", "ilike", "like", "match", "startswith"]
</pre>
              </dd>

              <dt><code>query</code></dt>

              <dd>
                takes a list of queries <code>q</code> and the
                format argument. The syntax of the query looks
                like:
                <pre>
CONJUNCTION+[OPEN_GROUP+]FIELD+OPERATOR+VALUE[+CLOSE_GROUP]
</pre>

                <p>where</p>

                <dl>
                  <dt><code>CONJUNCTION</code></dt>

                  <dd><kbd>and</kbd> or <kbd>or</kbd></dd>

                  <dt><code>OPEN_GROUP</code></dt>

                  <dd>optional, one or more <kbd>(</kbd></dd>

                  <dt><code>FIELD</code></dt>

                  <dd>e.g. <var>idx</var> or
                  <var>description</var></dd>

                  <dt><code>OPERATOR</code></dt>

                  <dd>e.g. <kbd>contains</kbd> or
                  <kbd>between</kbd>, one of the operators returned
                  by <code>get_query_operators</code></dd>

                  <dt><code>VALUE</code></dt>

                  <dd>e.g. <samp>euro4m</samp> or
                  <samp>200</samp></dd>

                  <dt><code>CLOSE_GROUP</code></dt>

                  <dd>optional, one or more <kbd>)</kbd></dd>
                </dl>

                <p>The first <code>CONJUNCTION</code> is
                technically superfluous. The
                <code>OPEN_GROUP</code> and
                <code>CLOSE_GROUP</code> do not have to be used.
                Entering this URL in a web browser:</p>
                <pre>
http://host/PREFIX_NAME/query?q=and+idx+endswith+78&amp;q=or+owner+eq+bob&amp;format=json
</pre>

                <p>may give</p>
                <pre class="prettyprint">
[{"idx": "mo1-aa078", "branch": "trunk", "revision": 200, "owner": "fred",
  "project": "fred's project.", "title": "fred's awesome suite",
  "status": "M ", "access-list": ["fred", "jack"], "description": "awesome"},
 {"idx": "mo1-aa090", "branch": "trunk", "revision": 350, "owner": "bob",
  "project": "var", "title": "A copy of var.vexcs.", "status": "M ",
  "access-list": ["*"], "operational": "Y"}]
</pre>

                <p>This returned all current suites that have an
                idx that ends with <samp>78</samp> and also all
                suites that have the owner <samp>bob</samp>. Each
                suite is returned as an entry in a list - each
                entry is an associative array of property
                name-value pairs. These pairs contain all database
                information about a suite.</p>

                <p><code>query</code> also takes the optional
                argument <code>all_revs</code> which switches on
                searching older revisions of current suites and
                deleted suites. For example, entering this URL in a
                web browser:</p>
                <pre>
http://host/mo1/json/query?q=and+idx+endswith+78&amp;all_revs&amp;format=json
</pre>

                <p>may give</p>
                <pre class="prettyprint">
[{"idx": "mo1-aa078", "branch": "trunk", "revision": 120, "owner": "fred",
  "project": "fred's project.", "title": "fred's new suite",
  "status": "A "}
 {"idx": "mo1-aa078", "branch": "trunk", "revision": 199, "owner": "fred",
  "project": "fred's project.", "title": "fred's awesome suite",
  "status": "M ", "access-list": ["fred", "jack"], "description": "awesome"},
 {"idx": "mo1-aa078", "branch": "trunk", "revision": 200, "owner": "fred",
  "project": "fred's project.", "title": "fred's awesome suite",
  "status": "M ", "access-list": ["fred", "jack"], "description": "awesome"}]
</pre>
              </dd>

              <dd>
                <p>This returned all past and present suites that
                have an idx that ends with <samp>78</samp>. You can
                see that older revisions of the <samp>aa078</samp>
                suite appear.</p>
              </dd>

              <dd>
                <p>You can also use parentheses in your search to
                group expressions. For example, entering this URL
                in a web browser:</p>
                <pre>
http://host/PREFIX_NAME/query?q=and+(+owner+eq+bob&amp;q=or+owner+eq+fred+)&amp;q=and+project+eq+test&amp;format=json
</pre>

                <p>would search for all suites that are owned by
                <samp>bob</samp> or <samp>fred</samp> that have the
                project <samp>test</samp>.</p>
              </dd>

              <dt><code>search</code></dt>

              <dd>
                takes any number of string arguments and the format
                argument and returns a list of matching suites with
                properties in the same format as
                <code>query</code>. The suite database is searched
                for suites with any property with a value that
                contains any of the string arguments. For example,
                entering this URL in a web browser:
                <pre>
http://host/PREFIX_NAME/search?var+bob+nowcast&amp;format=json
</pre>

                <p>may give</p>
                <pre class="prettyprint">
[{"idx": "mo1-aa090", "branch": "trunk", "revision": 330, "owner": "bob",
  "project": "um", "title": "A copy of um.alpra.", "status": "M ",
  "description": "Bob's UM suite"},
 {"idx": "mo1-aa092", "branch": "trunk", "revision": 340, "owner": "jim",
  "project": "var", "title": "6D Quantum VAR.", "status": "M ",
  "location": "NAE"},
 {"idx": "mo1-aa100", "branch": "trunk", "revision": 352, "owner": "ops_account",
  "project": "nowcast", "title": "The operational Nowcast suite",
  "status": "M ", "ensemble": "yes"}]
</pre>

                <p>This returned all suites that contain one or
                more of these search terms. Each suite is returned
                as an entry in a list, and each entry is an
                associative array of suite property name-value
                pairs. These pairs contain all database information
                about a suite.</p>

                <p><code>search</code> also takes the optional
                argument <code>all_revs</code> in the same way as
                <code>query</code>, above. This switches on
                searching older revisions of current suites and
                deleted suites. For example, entering this URL in a
                web browser:</p>
                <pre>
http://host/PREFIX_NAME/search?var+bob&amp;all_revs&amp;format=json
</pre>

                <p>may give</p>
                <pre class="prettyprint">
[{"idx": "mo1-aa001", "branch": "trunk", "revision": 120, "owner": "bob",
  "project": "useless", "title": "Bob's useless suite.", "status": "A "},
 {"idx": "mo1-aa001", "branch": "trunk", "revision": 122, "owner": "bob",
  "project": "useless", "title": "Bob's useless suite.", "status": "D "},
 {"idx": "mo1-aa090", "branch": "trunk", "revision": 320, "owner": "bob",
  "project": "um", "title": "A copy of um.alpra.", "status": "A "},
 {"idx": "mo1-aa090", "branch": "trunk", "revision": 321, "owner": "bob",
  "project": "um", "title": "A copy of um.alpra.", "status": "M "},
 {"idx": "mo1-aa090", "branch": "trunk", "revision": 330, "owner": "bob",
  "project": "um", "title": "A copy of um.alpra.", "status": "M "},
 {"idx": "mo1-aa092", "branch": "trunk", "revision": 335, "owner": "jim",
  "project": "var", "title": "6D Quantum VAR.", "status": "A "},
 {"idx": "mo1-aa092", "branch": "trunk", "revision": 338, "owner": "jim",
  "project": "var", "title": "6D Quantum VAR.", "status": "M ",
  "location": "Africa"},
 {"idx": "mo1-aa092", "branch": "trunk", "revision": 340, "owner": "jim",
  "project": "var", "title": "6D Quantum VAR.", "status": "M ",
  "location": "NAE"}]

</pre>
              </dd>

              <dd>
                <p>This returned all past and present suites that
                contained a match for at least one of the search
                terms. Older versions of suites appear, and you can
                also see a deleted suite (<samp>aa001</samp>).</p>
              </dd>
            </dl>

            <h2 id="library">Rose Python Modules</h2>

            <p>This gives some brief information about Rose python
            modules. For more information, see the files
            themselves.</p>

            <h3 id="library:rose">Rose Main Modules</h3>

            <p>This section describes the modules under the
            <code>lib/python/rose</code> package.</p>

            <dl>
              <dt><code>rose</code></dt>

              <dd>(<code>__init__.py</code>) stores some constants
              used by Rose programs.</dd>

              <dt><code>rose.app_run</code></dt>

              <dd>callable, Rose application runner.</dd>

              <dt><code>rose.apps.*</code></dt>

              <dd>(package) built-in Rose applications.</dd>

              <dt><code>rose.bush</code></dt>

              <dd>callable, Rose Bush services logic.</dd>

              <dt><code>rose.c3</code></dt>

              <dd>library, implements the C3 algorithm (e.g. to
              linearise multiple inheritance).</dd>

              <dt><code>rose.checksum</code></dt>

              <dd>library, determine the MD5 checksum for a file or
              files in a directory.</dd>

              <dt><code>rose.config</code></dt>

              <dd>library, parses and dumps rose configuration
              files. Contains the main configuration object
              <code>rose.config.ConfigNode</code> which is
              manipulated in most rose programs.</dd>

              <dt><code>rose.config_cli</code></dt>

              <dd>callable, implements the <kbd>rose config</kbd>
              command.</dd>

              <dt><code>rose.config_dump</code></dt>

              <dd>callable, implements the <kbd>rose
              config-dump</kbd> command.</dd>

              <dt><code>rose.config_editor/*</code></dt>

              <dd>(package) Rose configuration editor logic. See
              <a href="#library:rose:config_edit">Rose Config
              Editor Modules</a>.</dd>

              <dt><code>rose.config_processor</code></dt>

              <dd>library, base class for rose configuration
              processing.</dd>

              <dt><code>rose.config_processors</code></dt>

              <dd>(package) subclasses for rose configuration
              processing.</dd>

              <dt><code>rose.config_tree</code></dt>

              <dd>library, representation of a Rose configruation
              directory.</dd>

              <dt><code>rose.date</code></dt>

              <dd>callable, implements the <kbd>rose date</kbd>
              command. Contains date shift library.</dd>

              <dt><code>rose.env</code></dt>

              <dd>library, handles environment variable
              substitution.</dd>

              <dt><code>rose.env_cat</code></dt>

              <dd>callable, implements <kbd>rose env-cat</kbd>
              command.</dd>

              <dt><code>rose.external</code></dt>

              <dd>library, contains minimal wrapper functions for
              calling external programs.</dd>

              <dt><code>rose.formats</code></dt>

              <dd>(package) contains modules that deal with
              supported format parsing. The only current supported
              format is Fortran namelist, through
              <code>rose.formats.namelist</code>.</dd>

              <dt><code>rose.fs_util</code></dt>

              <dd>library, file system utilities with event
              reporting.</dd>

              <dt><code>rose.gtk</code></dt>

              <dd>(package) contains modules that deal with generic
              GTK operations and contain shared widgets.</dd>

              <dt><code>rose.host_select</code></dt>

              <dd>callable, ranks and selects host machines.</dd>

              <dt><code>rose.job_runner</code></dt>

              <dd>library, run jobs with multiple processes.</dd>

              <dt><code>rose.macro</code></dt>

              <dd>callable, runs internal and custom macros for an
              application or suite.</dd>

              <dt><code>rose.macros</code></dt>

              <dd>(package) Built-in macros. See <a href=
              "#library:rose:macros">Rose Build-in Macro
              Modules</a>.</dd>

              <dt><code>rose.meta_type</code></dt>

              <dd>library, classes for the various metadata
              <code>type</code> groups.</dd>

              <dt><code>rose.meta_type</code></dt>

              <dd>library, data types in a Rose configuration
              metadata.</dd>

              <dt><code>rose.metadata_check</code></dt>

              <dd>callable, validates configuration metadata.</dd>

              <dt><code>rose.metadata_gen</code></dt>

              <dd>callable, generates template metadata for an
              application.</dd>

              <dt><code>rose.metadata_graph</code></dt>

              <dd>callable, implement the <code>rose
              metadata-graph</code> command.</dd>

              <dt><code>rose.namelist_dump</code></dt>

              <dd>callable, dumps namelist files to a Rose
              configuration object.</dd>

              <dt><code>rose.opt_parse</code></dt>

              <dd>library, contains an
              <code>optparse.OptionParser</code> subclass. All
              command-line option parsing in Rose should use
              this.</dd>

              <dt><code>rose.popen</code></dt>

              <dd>library, utilities for spawning and monitoring
              processes.</dd>

              <dt><code>rose.resource</code></dt>

              <dd>library, locates files or directories.</dd>

              <dt><code>rose.run</code></dt>

              <dd>library, base class for application, suite and
              task runners.</dd>

              <dt><code>rose.run_source_vc</code></dt>

              <dd>library, functions to print out version control
              information for <code>rose suite-run</code>.</dd>

              <dt><code>rose.scheme_handler</code></dt>

              <dd>library, logic to load python modules based on
              named schemes.</dd>

              <dt><code>rose.section</code></dt>

              <dd>library, contains section-specific data
              utilities. Counterpart of
              <code>rose.variable</code>.</dd>

              <dt><code>rose.stem</code></dt>

              <dd>callable, converts user-friendly options for
              testing code into options for rose suite-run.</dd>

              <dt><code>rose.suite_clean</code></dt>

              <dd>callable, remove runtime directories of
              suites.</dd>

              <dt><code>rose.suite_control</code></dt>

              <dd>Invoke control commands (currently gcontrol and
              shutdown) of a running suite.</dd>

              <dt><code>rose.suite_engine_proc</code></dt>

              <dd>library, base class and utilities for interacting
              with a suite engine.</dd>

              <dt><code>rose.suite_engine_procs</code></dt>

              <dd>(package) library for interacting with specific
              suite engines.</dd>

              <dt><code>rose.suite_hook</code></dt>

              <dd>callable, hooks to suite engine events.</dd>

              <dt><code>rose.suite_log</code></dt>

              <dd>callable, implements the <code>rose
              suite-log</code> command.</dd>

              <dt><code>rose.suite_restart</code></dt>

              <dd>callable, implements the <code>rose
              suite-restart</code> command.</dd>

              <dt><code>rose.suite_run</code></dt>

              <dd>callable, suite runner.</dd>

              <dt><code>rose.suite_scan</code></dt>

              <dd>callable, scans for running suites.</dd>

              <dt><code>rose.task_env</code></dt>

              <dd>callable, provides an environment for a suite
              task.</dd>

              <dt><code>rose.task_run</code></dt>

              <dd>callable, task runner.</dd>

              <dt><code>rose.upgrade</code></dt>

              <dd>library, provides configuration upgrade
              functionality.</dd>

              <dt><code>rose.variable</code></dt>

              <dd>library, utilities for processing metadata and a
              basic data structure used by the config editor to
              hold values and metadata for options.</dd>

              <dt><code>rose.ws</code></dt>

              <dd>library, logic for web services, e.g. Rose Bush
              and Rosie Disco.</dd>
            </dl>

            <h3 id="library:rose:config_edit">Rose Config Editor
            Modules</h3>

            <p>This section describes the modules under the
            <code>lib/python/rose/config_editor</code> package.
            These are specific to the config editor.</p>

            <dl>
              <dt><code>rose.config_editor</code></dt>

              <dd>(<code>__init__.py</code>) stores some constants
              used for display in the config editor. All of these
              can be overridden using your user config.</dd>

              <dt><code>rose.config_editor.keywidget</code>,
              <code>rose.config_editor.menuwidget</code>,
              <code>rose.config_editor.pagewidget</code> (package),
              <code>rose.config_editor.variable</code>,
              <code>rose.config_editor.valuewidget</code>
              (package)</dt>

              <dd>These contain GTK code that control the
              adding/removing/modifying of options on a config
              editor tab. These can all be overridden using custom
              widgets (especially
              <code>rose.config_editor.valuewidget</code>
              modules).</dd>

              <dt><code>rose.config_editor.loader</code></dt>

              <dd>This controls the loading and retrieval of
              configuration data within the config editor.</dd>

              <dt><code>rose.config_editor.main</code></dt>

              <dd>This contains the centralised main control code
              of the config editor - updates, undo stack, etc.</dd>

              <dt><code>rose.config_editor.menu</code></dt>

              <dd>This module contains the menu for the config
              editor and various menu-related functions such as
              adding and removing sections.</dd>

              <dt><code>rose.config_editor.page</code></dt>

              <dd>This module contains control code for each config
              editor tab, and interfaces with
              <code>rose.config_editor.pagewidget</code> objects
              (including custom pages).</dd>

              <dt><code>rose.config_editor.panel</code></dt>

              <dd>This creates and alters the GTK Treeview panel of
              the config editor.</dd>

              <dt><code>rose.config_editor.stack</code></dt>

              <dd>This holds the <var>Undo</var> and
              <var>Redo</var> stack templates, and contains various
              functions to alter variables. This is the main
              functional interface for custom pages.</dd>

              <dt><code>rose.config_editor.util</code></dt>

              <dd>Various small utilities.</dd>

              <dt><code>rose.config_editor.window</code></dt>

              <dd>Creates the main GTK window of the config editor
              and provides functions to launch dialogs.</dd>
            </dl>

            <h3 id="library:rose:macros">Rose Built-in Macro
            Modules</h3>

            <p>The <code>lib/python/rose/macros</code> package
            contains built-in macros that perform checking against
            metadata. Most of these are run each time something
            changes in the config editor. They can be run on the
            command line via <code>rose macro</code>.</p>

            <dl>
              <dt><code>rose.macros.compulsory</code></dt>

              <dd>checks/fixes <var>compulsory</var> sections and
              options</dd>

              <dt><code>rose.macros.format</code></dt>

              <dd>checks format-specific sections and options,
              using options in <code>rose.formats</code>
              modules</dd>

              <dt><code>rose.macros.rule</code></dt>

              <dd>checks <var>fail-if</var> and <var>warn-if</var>
              metadata conditions</dd>

              <dt><code>rose.macros.trigger</code></dt>

              <dd>checks <var>trigger</var> validity and transforms
              configuration ignored states</dd>

              <dt><code>rose.macros.value</code></dt>

              <dd>checks <var>type</var>, <var>range</var>,
              <var>length</var>, <var>pattern</var>, or
              <var>values</var> metadata</dd>
            </dl>

            <h3 id="library:rosie">Rosie Modules</h3>

            <p>This section describes the modules under the
            <code>lib/python/rosie</code> package.</p>

            <dl>
              <dt><code>rosie.browser</code></dt>

              <dd>(package) GTK client code for rosie (<code>rosie
              go</code>).</dd>

              <dt><code>rosie.browser.history</code></dt>

              <dd>Methods and classes for recording suite search
              history. Used by <code>rosie go</code>.</dd>

              <dt><code>rosie.browser.main</code></dt>

              <dd>Main control code for <code>rosie go</code>.</dd>

              <dt><code>rosie.browser.result</code></dt>

              <dd>Custom widget with methods for displaying suite
              search results. Used by <code>rosie go</code>.</dd>

              <dt><code>rosie.browser.status</code></dt>

              <dd>Classes for getting and updating statuses for
              checked out suites. Used by <code>rosie
              go</code>.</dd>

              <dt><code>rosie.browser.suite</code></dt>

              <dd>Contains a wrapper class for handling the
              creation, copying, checking out and deleting of
              suites. Used by <code>rosie go</code>.</dd>

              <dt><code>rosie.browser.util</code></dt>

              <dd>Library of widgets for
              <code>rosie.browser</code>.</dd>

              <dt><code>rosie.db</code></dt>

              <dd>Interface code to the suite database, called by
              the web server.</dd>

              <dt><code>rosie.db_create</code></dt>

              <dd>Callable, implements <code>rosa db-create</code>
              command.</dd>

              <dt><code>rosie.graph</code></dt>

              <dd>Callable, implements <code>rosie graph</code>
              command.</dd>

              <dt><code>rosie.suite_id</code></dt>

              <dd>Callable, implements the <code>rosie id</code>
              command to identify suites.</dd>

              <dt><code>rosie.svn_post_commit</code></dt>

              <dd>Callable, implements the <code>rosa
              svn-post-commit</code> command.</dd>

              <dt><code>rosie.svn_pre_commit</code></dt>

              <dd>Callable, implements the <code>rosa
              svn-pre-commit</code> command.</dd>

              <dt><code>rosie.usertools.*</code></dt>

              <dd>(package) logic shared by <code>rosa
              svn-post-commit</code> and <code>rosa
              svn-pre-commit</code> for accessing user information,
              e.g. from Unix password file or LDAP.</dd>

              <dt><code>rosie.vc</code></dt>

              <dd>Callable, implements wrappers to version control
              system.</dd>

              <dt><code>rosie.ws</code></dt>

              <dd>Callable, Rosie Discovery service (Rosie
              Disco).</dd>

              <dt><code>rosie.ws_client</code></dt>

              <dd>Library, Rosie Disco clients.</dd>

              <dt><code>rosie.ws_client_auth</code></dt>

              <dd>Library, Rosie Disco client authentication
              schemes and keyring management.</dd>

              <dt><code>rosie.ws_client_cli</code></dt>

              <dd>Callable, Rosie Disco CLI clients.</dd>
            </dl>

            <h2 id="bash">Rose Bash Library</h2>

            <p>They live under <code>lib/bash/</code>. Each module
            contains a set of functions. To import a module, load
            the file into your script. E.g. To load
            <kbd>rose_usage</kbd>, you would do:</p>
            <pre class="prettyprint">
. $ROSE_HOME/lib/bash/rose_usage
</pre>

            <p>The modules are:</p>

            <dl>
              <dt><code>rose_init</code></dt>

              <dd>Called by <kbd>rose</kbd> on initialisation. This
              is not meant to be a module for general use.</dd>

              <dt><code>rose_log</code></dt>

              <dd>Provide functions to print log messages.</dd>

              <dt><code>rose_usage</code></dt>

              <dd>If your script has a header similar to the ones
              used by a Rose command line utility, you can use this
              function to print the synopsis section of the script
              header.</dd>
            </dl>
          </div>

          <div id="footer" class="panel-footer">
            <ul class="nav nav-pills" id="pagenav">
              <li><button id="back-button" class=
              "btn btn-default">Previous</button></li>

              <li><button id="next-button" class=
              "btn btn-primary">Next</button></li>
            </ul>

            <ul class="nav nav-pills" id="control-nav">
              <li>
                <div id="controls"></div>
              </li>
            </ul>

            <ul class="nav nav-pills pull-right">
              <li>
                <div id="currentSlide"></div>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</body>
</html>
